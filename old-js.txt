import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';
// Use the default export (singleton instance)
import quizEngine from './QuizEngine.js'; 
import webRTCManager from './WebRTCManager.js';
import { getTextTemplate } from '../utils/miscUtils.js';
// Import MSG_TYPE constants
import { MSG_TYPE } from '../core/message-types.js'; 

// Define a fallback constant for client_ready in case the import fails
const CLIENT_READY = 'client_ready';

/**
 * Manages the host-side logic for the **lobby phase** of a multiplayer game session.
 * - Initializes hosting via WebRTCManager.
 * - Listens for client connections/disconnections.
 * - Handles join requests and manages the player list *before* the game starts.
 * - Broadcasts player list updates to clients in the lobby.
 */
class MultiplayerHostManager {
    /**
     * @param {string} hostName The name of the host player.
     * @param {string[]} sheetIds Selected sheet IDs for the quiz.
     * @param {string} difficulty Selected difficulty level.
     * @param {string} hostId The PeerJS ID assigned to this host.
     */
    constructor(hostName, sheetIds, difficulty, hostId) {
        console.log(`[${this.constructor.name}] Initializing with Host ID: ${hostId}`);
        this.hostName = hostName;
        this.hostId = hostId; // The host's own PeerJS ID
        this.settings = { sheetIds, difficulty, hostId }; // Store settings
        this.isHosting = false; // Is the lobby active?
        this.gameHasStarted = false; // Added this flag

        // Use the imported singleton instance
        this.quizEngine = quizEngine.getInstance(); // Get the singleton instance

        // Player Management for lobby
        /** @type {Map<string, { name: string, isReady: boolean }>} */
        this.players = new Map();
        /** @type {Set<string>} Peers who have requested a rematch */
        this._rematchRequestedPeers = new Set(); 

        // Add host immediately, marked as ready
        this.addPlayer(this.hostId, this.hostName, true); 

        // Bind methods for listeners
        this._boundHandleClientConnected = this.handleClientConnected.bind(this);
        this._boundHandleClientDisconnected = this.handleClientDisconnected.bind(this);
        this._boundHandleDataReceived = this.handleDataReceived.bind(this);
        this._boundHandlePlayerListUpdate = this._handlePlayerListUpdate.bind(this);
    }

    /**
     * Asynchronously loads necessary data via QuizEngine *before* hosting starts.
     * (Required by GameCoordinator before calling startHosting).
     * @throws {Error} If QuizEngine fails to load questions.
     */
    async initialize() {
        console.log(`[${this.constructor.name}] Initializing QuizEngine via loadQuestions...`);
        try {
            // Use loadQuestions with stored settings
            await this.quizEngine.loadQuestionsFromManager(this.settings.sheetIds, this.settings.difficulty);
            console.log(`[${this.constructor.name}] QuizEngine questions loaded successfully.`);
            // Use getQuestionCount
            if (this.quizEngine.getQuestionCount() === 0) {
                 console.error(`[${this.constructor.name}] Initialization failed: No questions found for the selected sheets.`);
                 throw new Error(getTextTemplate('mpHostErrorNoQuestions'));
            }
        } catch (error) {
            console.error(`[${this.constructor.name}] Error loading questions via QuizEngine:`, error);
            // Rethrow a user-friendly error or a specific error type
            throw new Error(getTextTemplate('mpHostErrorQuizEngineInitFail', { '%MSG%': error.message }));
        }
    }

    /**
     * Starts the lobby hosting phase.
     * Listens for client connections and lobby-related messages.
     */
    startHosting() {
        if (this.isHosting) {
            console.warn(`[${this.constructor.name}] Already hosting.`);
            return;
        }
        console.log(`[${this.constructor.name}] Starting hosting (Lobby Phase)... Listening for clients.`);
        this.isHosting = true;
        // Listen for direct connection events from WebRTCManager
        eventBus.on(Events.Multiplayer.Host.ClientConnected, this._boundHandleClientConnected);
        eventBus.on(Events.Multiplayer.Host.ClientDisconnected, this._boundHandleClientDisconnected);
        // Listen for messages (join requests, ready signals)
        eventBus.on(Events.WebRTC.MessageReceived, this._boundHandleDataReceived); 
        // Listen for player list updates from WebRTCManager (handles name changes etc.)
        eventBus.on(Events.Multiplayer.Common.PlayerListUpdated, this._boundHandlePlayerListUpdate);
    }

    /**
     * Stops the lobby hosting phase.
     * Removes listeners and cleans up lobby state.
     */
    stopHosting() {
        if (!this.isHosting) {
            return;
        }
        console.log(`[${this.constructor.name}] Stopping hosting (Lobby Phase)...`);
        this.isHosting = false;
        // Remove listeners
        eventBus.off(Events.Multiplayer.Host.ClientConnected, this._boundHandleClientConnected);
        eventBus.off(Events.Multiplayer.Host.ClientDisconnected, this._boundHandleClientDisconnected);
        eventBus.off(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);
        eventBus.off(Events.Multiplayer.Common.PlayerListUpdated, this._boundHandlePlayerListUpdate);
        // Optionally, clear player list or keep it? Let's clear for a clean stop.
        // this.players.clear(); 
    }

    /**
     * Adds a player to the lobby list or updates their info.
     * Triggers a broadcast of the updated player list if lobby hosting is active.
     * @param {string} peerId The PeerJS ID of the player.
     * @param {string} name The player's name.
     * @param {boolean} isReady Initial ready state.
     * @private
     */
    addPlayer(peerId, name, isReady = false) {
        const defaultName = name || getTextTemplate('mcDefaultPlayerName');
        const playerExists = this.players.has(peerId);
        const existingPlayer = playerExists ? this.players.get(peerId) : null;

        let changed = false;
        
        if (!playerExists) {
            // Add new player
            this.players.set(peerId, {
                name: defaultName,
                isReady: isReady // Store only lobby-relevant state
            });
            console.log(`[${this.constructor.name} Lobby] Player added: ${defaultName} (${peerId}), Ready: ${isReady}`);
            changed = true;
        } else {
            // Update existing player if necessary
            let updated = false;
            if (existingPlayer.name !== defaultName) {
                console.log(`[${this.constructor.name} Lobby] Player ${peerId} updated name to: ${defaultName}`);
                existingPlayer.name = defaultName;
                updated = true;
            }
            // Update ready status if different
            if (existingPlayer.isReady !== isReady) {
                console.log(`[${this.constructor.name} Lobby] Player ${peerId} updated ready status to: ${isReady}`);
                existingPlayer.isReady = isReady;
                updated = true;
            }
            if (updated) {
                changed = true;
            }
        }
        
        // If anything changed AND hosting is active, broadcast and update local UI
        if (changed && this.isHosting) {
            console.log(`[${this.constructor.name} Lobby] Player list changed, broadcasting update.`);
            this._broadcastPlayerListUpdate();
            // Also emit locally for host UI
            eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: this.players });
        } else if (changed) {
             console.log(`[${this.constructor.name} Lobby] Player list changed, but not broadcasting (hosting not active).`);
        }
    }

    /**
     * Removes a player from the lobby list.
     * @param {string} peerId The PeerJS ID of the player to remove.
     * @private
     */
    removePlayer(peerId) {
        if (this.players.has(peerId)) {
            const removedPlayerName = this.players.get(peerId).name;
            this.players.delete(peerId);
            console.log(`[${this.constructor.name} Lobby] Player removed: ${removedPlayerName} (${peerId})`);
            // Update player list for everyone if hosting is active
             if (this.isHosting) {
                 this._broadcastPlayerListUpdate();
                 // Also emit locally for host UI
                 eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: this.players });
            }
        }
    }

    /**
     * Handles a client successfully connecting (via WebRTCManager event).
     * Adds player to lobby list (as not ready initially).
     * @param {object} payload
     * @param {string} payload.peerId Client's PeerJS ID.
     * @param {string} payload.playerName Client's reported name.
     */
    handleClientConnected({ peerId, playerName }) {
        console.log(`[${this.constructor.name} Lobby] Client connected event: ${playerName} (${peerId})`);
        // Add player as not ready. addPlayer handles broadcast.
        this.addPlayer(peerId, playerName, false); 
    }

    /**
     * Handles a client disconnecting (via WebRTCManager event).
     * Removes player from lobby list.
     * @param {object} payload
     * @param {string} payload.peerId Client's PeerJS ID.
     */
    handleClientDisconnected({ peerId }) {
        console.log(`[${this.constructor.name} Lobby] Client disconnected: ${peerId}`);
        const playerName = this.players.get(peerId)?.name || 'Unknown';
        this.removePlayer(peerId);
        this._rematchRequestedPeers.delete(peerId); // <<< Clear rematch request on disconnect

        // Host UI update handled by removePlayer
        eventBus.emit(Events.System.ShowFeedback, { message: getTextTemplate('mpHostLobbyCancelled', {'%NAME%': playerName }), level: 'info' });
    }

    /**
     * Handles data messages received from any connected client *during the lobby phase*.
     * Primarily handles 'c_requestJoin' and 'client_ready'.
     * @param {object} eventData - Payload from Events.WebRTC.MessageReceived.
     * @param {any} eventData.msg - The received message data { type: string, payload: any }.
     * @param {string} eventData.sender - The PeerJS ID of the client who sent the message.
     */
    handleDataReceived({ msg, sender }) {
        // Ignore if lobby isn't active or sender is host/unknown
        if (!this.isHosting || !this.players.has(sender) || sender === this.hostId) {
            console.warn(`[${this.constructor.name}] Ignoring message (hosting: ${this.isHosting}, sender known: ${this.players.has(sender)}, is host: ${sender === this.hostId})`, msg);
            return; 
        }

        const type = msg.type;
        const payload = msg.payload;
        const playerName = this.players.get(sender)?.name || sender;

        // Only process lobby-relevant messages
        // Create a combined list of accepted types, accounting for potential undefined values
        const clientReadyType = MSG_TYPE.CLIENT_READY || CLIENT_READY;
        const acceptedTypes = [MSG_TYPE.C_REQUEST_JOIN, clientReadyType, MSG_TYPE.C_REQUEST_REMATCH];
        if (!acceptedTypes.includes(type)) {
             console.log(`[${this.constructor.name} Lobby] Ignoring non-lobby message type '${type}' from ${playerName} (${sender})`);
             return;
        }

        console.log(`[${this.constructor.name} Lobby] Received lobby message from ${playerName} (${sender}): Type=${type}`, payload);

        switch (type) {
            case MSG_TYPE.C_REQUEST_JOIN: 
                 const requestedName = payload?.name;
                 if (requestedName) {
                     console.log(`[${this.constructor.name} Lobby] Processing join request for ${sender} with name: ${requestedName}`);
                     // Update player name if needed, keep ready status false until confirmed
                     this.addPlayer(sender, requestedName, false); 
                 } else {
                      console.warn(`[${this.constructor.name} Lobby] Received c_requestJoin from ${sender} without a name.`);
                 }
                 break;
            // Use both possible type values for CLIENT_READY
            case clientReadyType:
            case CLIENT_READY: // Explicit fallback
                 console.log(`[${this.constructor.name} Lobby] Processing CLIENT_READY message from ${playerName} (${sender})`, payload);
                 const player = this.players.get(sender);
                 if (player) {
                     console.log(`[${this.constructor.name} Lobby] Current player data:`, player);
                     if (!player.isReady) {
                         console.log(`[${this.constructor.name} Lobby] Marking player ${playerName} (${sender}) as ready.`);
                         
                         // Extract isReady from payload if available, otherwise default to true
                         const isReady = payload && typeof payload.isReady === 'boolean' ? payload.isReady : true;
                         console.log(`[${this.constructor.name} Lobby] isReady value from payload: ${isReady}`);
                         
                         // Force isReady to true regardless of message payload structure
                         this.addPlayer(sender, player.name, isReady);
                         
                         // Force broadcast the player list update to ensure all clients receive it
                         this._broadcastPlayerListUpdate();
                         
                         // Also force emit locally for host UI to ensure it updates
                         eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: this.players });
                         
                         // Manually log the player list after update to verify
                         console.log(`[${this.constructor.name} Lobby] Player list after update:`, Object.fromEntries(this.players));
                     } else {
                          console.log(`[${this.constructor.name} Lobby] Player ${playerName} (${sender}) already marked as ready.`);
                     }
                 } else {
                      console.warn(`[${this.constructor.name} Lobby] Received client_ready from unknown peer ${sender}`);
                 }
                break;
            case MSG_TYPE.C_REQUEST_REMATCH:
                if (!this._rematchRequestedPeers.has(sender)) {
                    console.log(`[${this.constructor.name} Lobby] Rematch requested by ${playerName} (${sender})`);
                    this._rematchRequestedPeers.add(sender);
                    // Optionally notify other players? For now, just track.
                    // Check if all connected players are now ready for rematch
                    this._checkRematchReadiness();
                } else {
                    console.log(`[${this.constructor.name} Lobby] Duplicate rematch request from ${playerName} (${sender})`);
                }
                break;
            default:
                // Should not be reached due to filter above
                console.warn(`[${this.constructor.name} Lobby] Unexpected message type: ${type}`);
        }
    }

    /**
     * Sends a message to all connected clients *in the lobby*.
     * @param {string} type - The message type identifier.
     * @param {object} payload - The data payload for the message.
     * @param {string[]} [excludePeerIds=[]] - Optional array of PeerJS IDs to exclude.
     * @private
     */
    _broadcast(type, payload, excludePeerIds = []) {
        if (!this.isHosting) return;
        console.log(`[${this.constructor.name} Lobby] Broadcasting: Type=${type} to clients (exclude: ${excludePeerIds.join(',') || 'none'})`, payload); 
        const allClients = Array.from(this.players.keys()).filter(id => id !== this.hostId);
        const excludedSet = new Set(excludePeerIds);

        let sentCount = 0;
        allClients.forEach(peerId => {
             if (!excludedSet.has(peerId)) {
                 webRTCManager.sendToPeer(peerId, type, payload); 
                 sentCount++;
            } 
        });
         console.log(`[${this.constructor.name} Lobby] Broadcast complete: Sent type '${type}' to ${sentCount}/${allClients.length} potential clients.`);
    }

    /**
     * Specifically broadcasts the current lobby player list to all clients.
     * @private
     */
    _broadcastPlayerListUpdate() {
         if (!this.isHosting) return;
         const playersObject = Object.fromEntries(this.players);
         console.debug(`[${this.constructor.name} Lobby] Broadcasting player_list_update. List:`, playersObject);
         this._broadcast('player_list_update', { players: playersObject }, []); 
    }

    /**
     * Called when the host cancels the lobby.
     * Informs clients and cleans up.
     */
    leaveLobby() {
        console.log(`[${this.constructor.name}] Host is leaving lobby.`);
        if (this.isHosting) {
             // Inform clients lobby is closing
             this._broadcast('feedback', { message: getTextTemplate('mpHostLobbyCancelled'), level: 'warn' }, []);
             // Short delay to allow message delivery?
             // setTimeout(() => {
                  this.stopHosting(); // Remove listeners
                  // GameCoordinator should call webRTCManager.closeConnection()
             // }, 500);
        } else {
            this.stopHosting(); // Ensure listeners are off even if called redundantly
        }
    }

    /**
     * Cleans up resources, removes listeners.
     */
    destroy() {
        console.log(`[${this.constructor.name}] Destroying...`);
        this.leaveLobby(); // Ensure lobby stops and listeners are removed
        this.players.clear();
        this.quizEngine = null; // Release reference
        this.isHosting = false;
        this._rematchRequestedPeers.clear(); // <<< Clear rematch requests on destroy
        console.log(`[${this.constructor.name}] Destroyed.`);
    }

    /**
     * [ADDED] Handles the PlayerListUpdated event from WebRTCManager.
     * Synchronizes the internal player list (names, etc.) with the authoritative list.
     * @param {object} payload
     * @param {Map<string, { name: string, isHost: boolean }>} payload.players The authoritative player list from WebRTCManager.
     * @private
     */
    _handlePlayerListUpdate({ players }) {
        if (!this.isHosting) return; // Only process if lobby is active

        console.log(`[${this.constructor.name} Lobby] Received PlayerListUpdated event from WebRTCManager. Synchronizing...`);
        
        // Iterate through the authoritative list from WebRTCManager
        players.forEach((playerData, peerId) => {
            if (peerId === this.hostId) return; // Ignore the host entry (managed separately)

            const existingPlayer = this.players.get(peerId);
            const webRTCName = playerData.name || getTextTemplate('mcDefaultPlayerName'); // Ensure a name exists
            
            if (!existingPlayer) {
                // Player is in WebRTC list but not ours? Add them (should be rare if ClientConnected worked)
                console.warn(`[${this.constructor.name} Lobby Sync] Adding missing player ${webRTCName} (${peerId})`);
                this.addPlayer(peerId, webRTCName, false); // Add as not ready initially
            } else if (existingPlayer.name !== webRTCName) {
                // Name mismatch? Update our record using addPlayer logic
                 console.log(`[${this.constructor.name} Lobby Sync] Updating name for ${peerId} from '${existingPlayer.name}' to '${webRTCName}'`);
                // Use addPlayer to ensure consistency and trigger broadcasts if needed
                // Keep existing ready status
                this.addPlayer(peerId, webRTCName, existingPlayer.isReady); 
            }
            // Note: We don't sync 'isReady' from this event, as that's managed by explicit 'client_ready' messages.
        });

        // Optional: Check for players in our list that are NO LONGER in the WebRTC list?
        // This shouldn't happen if disconnect events are working correctly.
        // const localPeerIds = new Set(this.players.keys());
        // localPeerIds.delete(this.hostId); // Don't check host
        // const webRTCPeerIds = new Set(players.keys());
        // localPeerIds.forEach(localPeerId => {
        //     if (!webRTCPeerIds.has(localPeerId)) {
        //         console.warn(`[${this.constructor.name} Lobby Sync] Player ${localPeerId} exists locally but not in WebRTC update. Removing.`);
        //         this.removePlayer(localPeerId);
        //     }
        // });
    }

    /**
     * [REVISED] Initiates the game start sequence.
     * Stops lobby listeners and broadcasts GAME_START.
     * Called by GameCoordinator for both initial start and rematches.
     */
    initiateGameStart() {
        if (!this.isHosting) {
            console.warn(`[${this.constructor.name}] initiateGameStart called, but not hosting.`);
            return;
        }

        // Prevent starting multiple times
        if (this.gameHasStarted) { // Assuming we add this flag
            console.warn(`[${this.constructor.name}] initiateGameStart called, but game sequence already started.`);
            return;
        }

        console.log(`[${this.constructor.name}] Initiating game start sequence...`);
        this.gameHasStarted = true; // Set flag

        // 1. Stop listening specifically for *lobby* events (join requests, ready)
        // Keep listeners for generic messages and disconnects active for the game phase.
        this.stopHosting(); // Rename or refine this if needed

        // 2. Broadcast GAME_START to all connected clients
        console.log(`[${this.constructor.name}] Broadcasting GAME_START.`);
        this._broadcast(MSG_TYPE.GAME_START, {
             // Payload might include final confirmed player list or initial game state if needed
             players: Object.fromEntries(this.players)
        });

        console.log(`[${this.constructor.name}] Game sequence initiated. GameCoordinator will create game instance.`);
    }

    /**
     * Checks if all currently connected clients have requested a rematch.
     * If so, initiates the rematch process.
     * @private
     */
    _checkRematchReadiness() {
        if (!this.isHosting) return; // Only check if hosting

        const connectedClientIds = Array.from(this.players.keys()).filter(id => id !== this.hostId);
        
        if (connectedClientIds.length === 0) {
            console.log(`[${this.constructor.name} Rematch Check] No clients connected, cannot start rematch.`);
            this._rematchRequestedPeers.clear(); 
            return;
        }

        const allReady = connectedClientIds.every(clientId => this._rematchRequestedPeers.has(clientId));

        if (allReady) {
            console.log(`[${this.constructor.name} Rematch Check] All ${connectedClientIds.length} client(s) ready for rematch! Initiating...`);
            
            // 1. Notify clients rematch is accepted/starting (Optional but good UX)
            this._broadcast(MSG_TYPE.H_REMATCH_ACCEPTED, {}, []); 

            // 2. Trigger the game start sequence (broadcasts GAME_START)
            this.initiateGameStart();

            // 3. Emit local event for GameCoordinator to create the Game Instance
            eventBus.emit(Events.Multiplayer.Host.RematchReady, {
                hostId: this.hostId,
                settings: this.settings,
                players: this.players 
            });

            // 4. Reset rematch state for the next round
            this._rematchRequestedPeers.clear();

        } else {
             const readyCount = connectedClientIds.filter(id => this._rematchRequestedPeers.has(id)).length;
             console.log(`[${this.constructor.name} Rematch Check] Waiting for rematch requests (${readyCount}/${connectedClientIds.length} ready).`);
        }
    }
}

export default MultiplayerHostManager; import Events from '../core/event-constants.js';
import eventBus from '../core/event-bus.js';
import miscUtils from '../utils/miscUtils.js'; // Import default
// Assuming PeerJS is loaded globally or correctly imported as 'Peer'
// import Peer from '../lib/peerjs.min.js'; // Keep if using module
import { ConnectionStatus, DataConnectionState, DisconnectionReason } from '../core/connection-constants.js'; // Import DisconnectionReason
import { MSG_TYPE } from '../core/message-types.js'; // ADDED: Import from new location

// Define message types used in communication
// export const MSG_TYPE = { ... }; // MOVED to v2/core/message-types.js

// Constants for Heartbeat/Timeout
const HEARTBEAT_INTERVAL_MS = 5000; // Check/Send every 5 seconds
const TIMEOUT_MS = 15000; // Consider connection lost after 15 seconds of silence

/**
 * Manages WebRTC connections using PeerJS for multiplayer games.
 * Handles host initialization, client connection, data messaging relay,
 * basic player state tracking (for connection management), and emits WebRTC/Multiplayer events.
 * It does NOT parse or handle game-specific message content; it emits raw messages via
 * Events.WebRTC.MessageReceived for other services (like MultiplayerGame/MultiplayerClientManager) to handle.
 */
class WebRTCManager {
    constructor() {
        /** @type {Peer | null} The PeerJS instance. */
        this.peer = null;
        /** @type {string | null} ID of the host we are connected to (client only). */
        this.hostId = null;
        /** @type {string | null} Our own PeerJS ID (6-digit code for host, GUID for client). */
        this.myPeerId = null;
        /** @type {Map<string, Peer.DataConnection>} Map<peerId, DataConnection> - Host: clients, Client: host */
        this.connections = new Map();
        /** @type {Map<string, DataConnectionState>} Map<peerId, state> Tracks individual connection states */
        this.connectionStates = new Map();
        /** @type {Map<string, { name?: string, isHost: boolean }>} Minimal player info needed by WebRTCManager (name from metadata) */
        this.players = new Map();
        /** @type {string} The local player's name. */
        this.localPlayerName = miscUtils.generateRandomPlayerName();
        /** @type {boolean} Whether this instance is acting as the host. */
        this.isHost = false;
        /** @type {object | null} Temporary storage for host game settings/data. */
        this.pendingHostGameData = null;
        /** @type {string | null} Difficulty setting for the host game. */
        this.pendingHostDifficulty = null;
        /** @type {ConnectionStatus} Current status of the connection manager. */
        this.status = ConnectionStatus.DISCONNECTED;
        /** @private Stores bound listener functions for easy removal */
        this._peerListeners = {};
        /** @private Stores bound listener functions for individual connections */
        this._connectionListeners = new Map();
        /** @private Interval ID for sending pings */
        this._pingIntervalId = null;
        /** @private Interval ID for checking timeouts */
        this._timeoutCheckIntervalId = null;
        /** @private Map<peerId, timestamp> Last contact time for clients (Host only) */
        this._clientLastContact = new Map();
        /** @private Timestamp Last contact time from host (Client only) */
        this._lastHostContact = null;
        /** @private Stores the actual PeerJS ID of the host */
        this.hostPeerId = null;
        /** @private Store original onerror */
        // this._originalOnError = window.onerror; // REMOVED
        /** @private Store our bound error handler */
        this._boundErrorHandler = this._handleGlobalError.bind(this);

        // Setup global error handler using addEventListener
        // window.onerror = this._boundErrorHandler; // REMOVED
        window.addEventListener('error', this._boundErrorHandler);

        console.info("[WebRTCManager] Initialized.");
    }

    /**
     * Handles uncaught global errors, attempting to log context.
     * @param {ErrorEvent} event - The global error event.
     * @private
     */
    _handleGlobalError(event) {
        const error = event.error || new Error(event.message || 'Unknown global error');
        const context = `global-${event.filename}:${event.lineno}:${event.colno}`;
        console.error(`[WebRTCManager] Uncaught Global Error (${context}):`, error);

        // Optionally emit a specific event for critical failures
        eventBus.emit(Events.System.Error, { 
            error: error, 
            message: `Unhandled error: ${error.message}`, 
            context: context,
            isFatal: false // Decide if this type of error should be considered fatal
        });
        
        // Prevent default browser error handling? Usually false.
        // event.preventDefault(); 
    }

    // --- Host Functionality ---

    /**
     * Initializes this peer as the host, using a generated 6-digit code as the Peer ID.
     * @param {string} playerName - The host's chosen name.
     * @param {object} questionsData - The structured question data object from QuestionsManager.
     * @param {string} difficulty - The selected game difficulty.
     * @throws {Error} If PeerJS initialization fails or another game is active.
     */
    startHost(playerName, questionsData, difficulty) {
        console.log(`[WebRTCManager] Attempting to start Host with 6-digit ID. Player: ${playerName}, Difficulty: ${difficulty}`);
        if (this.status !== ConnectionStatus.DISCONNECTED && this.status !== ConnectionStatus.ERROR) {
             const message = `[WebRTCManager] Cannot start host, current status is ${this.status}. Call closeConnection() first.`;
             console.error(message);
             throw new Error(message);
        }
        this.resetState();
        this.status = ConnectionStatus.INITIALIZING_PEER;
        this.isHost = true;
        this.localPlayerName = playerName;
        this.pendingHostGameData = questionsData || { sheets: [] }; // Store questions data
        this.pendingHostDifficulty = difficulty || 'normal'; // Store difficulty

        try {
            if (typeof Peer === 'undefined') {
                throw new Error(miscUtils.getTextTemplate('rtcErrorPeerJSLoad'));
            }

            // *** Generate 6-digit code to use AS Peer ID ***
            const generatedCodeId = Math.floor(100000 + Math.random() * 900000).toString();
            console.log(`[WebRTCManager] Generated 6-digit Host ID: ${generatedCodeId}`);
            this.myPeerId = generatedCodeId; // Store it immediately

            // *** Use the generated code as the Peer ID ***
            this.peer = new Peer(generatedCodeId, { debug: 2 }); // Pass code to constructor

            // Store bound listeners
            this._peerListeners.open = (id) => this._handleHostOpen(id);
            this._peerListeners.connection = (conn) => this._handleClientConnection(conn);
            this._peerListeners.error = (err) => this._handleError(err, 'host-peer');
            this._peerListeners.disconnected = () => this._handleDisconnection('host-disconnected-server');
            this._peerListeners.close = () => console.log('[WebRTCManager] Host Peer instance closed.');

            this.peer.on('open', this._peerListeners.open);
            this.peer.on('connection', this._peerListeners.connection);
            this.peer.on('error', this._peerListeners.error);
            this.peer.on('disconnected', this._peerListeners.disconnected);
            this.peer.on('close', this._peerListeners.close);

        } catch (error) {
            console.error("[WebRTCManager] Error creating host PeerJS instance:", error);
            eventBus.emit(Events.WebRTC.ConnectionFailed, { error, context: 'host-peer-creation', message: error.message });
            this.status = ConnectionStatus.ERROR;
            this.resetState();
        }

        // Add global error listener now that Peer is active
        window.addEventListener('error', this._boundErrorHandler);
        console.debug("[WebRTCManager] Added global error listener (host).");
    }

    /**
     * @private
     * @param {string} id The host PeerJS ID (should match the generated 6-digit code).
     */
    _handleHostOpen(id) {
        if (this.status !== ConnectionStatus.INITIALIZING_PEER) return;
        
        if (id !== this.myPeerId) {
            console.error(`[WebRTCManager] Mismatch! Host Peer opened with ID ${id}, but expected ${this.myPeerId}. Check PeerServer configuration or if ID was reused.`);
            this.myPeerId = id; 
            this.hostPeerId = id; 
        } else {
             this.hostPeerId = id;
        }
        
        console.log(`[WebRTCManager] Host PeerJS established. Assigned ID (6-digit): ${this.myPeerId}, Actual PeerJS ID used: ${this.hostPeerId}`);
        
        this.status = ConnectionStatus.AWAITING_CONNECTIONS;
        this._updatePlayer(this.myPeerId, { name: this.localPlayerName, isHost: true });

        eventBus.emit(Events.Multiplayer.Host.Initialized, {
            hostId: this.myPeerId,
            hostPeerId: this.hostPeerId
        });

        this._startHostHeartbeatBroadcast();
        this._startClientTimeoutCheck();

        // Add global error listener now that Peer is active
        window.addEventListener('error', this._boundErrorHandler);
        console.debug("[WebRTCManager] Added global error listener (host).");
    }

    /**
     * @private
     * @param {Peer.DataConnection} connection The incoming client connection.
     */
    _handleClientConnection(connection) {
        const peerId = connection.peer;

        // --- FIX: Safely handle potentially undefined metadata ---
        // Assign a temporary name. The actual name will come via 'client_hello'.
        const clientName = `Client_${peerId.slice(-4)}`; // Use placeholder initially
        console.log(`[WebRTCManager] Incoming connection request from: ${peerId} (Temp Name: ${clientName})`);
        // --- END FIX ---

        // Prevent duplicate connections (logic remains the same)
        if (this.connections.has(peerId)) {
            console.warn(`[WebRTCManager] Duplicate connection attempt from ${peerId}. Closing new attempt.`);
            connection.close();
            return;
        }

        // Store connection immediately (logic remains the same)
        this.connections.set(peerId, connection);
        this.connectionStates.set(peerId, DataConnectionState.OPENING);

        // Store bound listeners for this specific connection
        const connListeners = {
            open: () => {
                console.log(`[WebRTCManager] Data connection opened with client: ${peerId}`); // Log with PeerID initially
                // Connection is fully open
                this.connectionStates.set(peerId, DataConnectionState.OPEN);

                // Initialize last contact time for timeout check
                this._clientLastContact.set(peerId, Date.now());

                // Emit ClientConnected event WITHOUT name, as it's not confirmed yet.
                eventBus.emit(Events.Multiplayer.Host.ClientConnected, { peerId });

            },
            data: (rawData) => {
                // Wrap the entire handler content in a try-catch for robustness
                try {
                const peerId = connection.peer; // Capture peerId for this handler context
                    // +++ ADD RAW LOG +++
                    console.log(`%c[WebRTC RAW Host] Received data from ${peerId}:`, 'color: orange; font-weight: bold;', rawData); // Added color for visibility
                    // +++ END RAW LOG +++

                let messageData;
                    // Parsing logic (moved inside the main try-catch)
                try {
                    if (typeof rawData === 'string') {
                        messageData = JSON.parse(rawData);
                    } else if (typeof rawData === 'object' && rawData !== null) {
                        messageData = rawData;
                    } else {
                        console.error(`[WebRTCManager Host] Received unexpected data type from ${peerId}: ${typeof rawData}`, rawData);
                        return; // Ignore unexpected types
                        }
                    } catch (parseError) {
                        console.error(`[WebRTCManager Host] Failed to parse message JSON string in 'data' handler from ${peerId}:`, parseError, rawData);
                        this._handleClientDisconnection(peerId, 'message_parse_error');
                        return; // Stop processing if string parsing fails
                    }

                    // --- Add strict check for message type ---
                    if (!messageData || typeof messageData.type !== 'string') {
                        console.warn(`[WebRTCManager Host] Received message without a valid 'type' string from ${peerId}. Ignoring.`, messageData);
                        return;
                    }
                    // --- End check ---

                    // Update last contact time AFTER successful parsing and type check
                    this._clientLastContact.set(peerId, Date.now());

                    // --- ADD Handling for client_hello ---
                    if (messageData.type === 'client_hello' && messageData.payload) {
                        const playerName = messageData.payload.name || `Player_${peerId.slice(-4)}`;
                         console.log(`[WebRTCManager Host] Received client_hello from ${peerId}. Setting name to: ${playerName}`);
                         // Update the player list internally in WebRTCManager
                        this._updatePlayer(peerId, { name: playerName, isHost: false });

                         // --- FIX: Send Game Info AFTER hello ---
                         if (this.isHost) {
                            this._sendGameInfoToClient(connection);
                         }
                         // --- END FIX ---

                         // Emit the updated list (HostLobbyComponent and others listen for this)
                        eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: this.players });
                         // Also emit PlayerJoined now that we have the name
                         eventBus.emit(Events.Multiplayer.Common.PlayerJoined, { peerId, playerData: { name: playerName, isHost: false } });

                         // Do not emit MessageReceived further for this internal message type
                         return;
                    }
                    // --- END Handling for client_hello ---

                    // Pass other validated messages to the emit handler
                        this._emitMessageReceived(messageData, peerId);

                } catch (outerError) {
                     const currentPeerId = connection?.peer || 'unknown';
                     console.error(`[WebRTCManager Host] Unexpected error in 'data' handler for peer ${currentPeerId}:`, outerError);
                     if (currentPeerId !== 'unknown') {
                          this._handleClientDisconnection(currentPeerId, 'data_handler_unexpected_error');
                     }
                }
            },
            close: () => {
                 console.warn(`[WebRTCManager] Data connection closed for client: ${peerId}`);
                 this.connectionStates.set(peerId, DataConnectionState.CLOSED);
                 this._handleClientDisconnection(peerId, DisconnectionReason.CLOSED_BY_REMOTE);
            },
            error: (err) => {
                 console.error(`[WebRTCManager] Data connection error for client ${peerId}:`, err);
                 this.connectionStates.set(peerId, DataConnectionState.CLOSED);
                 this._handleClientDisconnection(peerId, DisconnectionReason.CONNECTION_ERROR);
                 // Optionally emit a specific error event?
                 eventBus.emit(Events.WebRTC.ConnectionFailed, { error: err, context: 'data-connection', peerId: peerId });
            }
        };
        this._connectionListeners.set(peerId, connListeners);

        connection.on('open', connListeners.open);
        connection.on('data', connListeners.data);
        connection.on('close', connListeners.close);
        connection.on('error', connListeners.error);
    }

    /**
     * Sends current game settings and player list to a specific new client.
     * @param {Peer.DataConnection} connection - The connection to the new client.
     * @private
     */
    _sendGameInfoToClient(connection) {
        if (!this.isHost || !connection || !connection.open) return;
        
        // Construct payload with full questions data and difficulty
        const gameInfoPayload = {
            questions: this.pendingHostGameData, // Send the full questions data structure
            difficulty: this.pendingHostDifficulty, // Send the difficulty
            players: Object.fromEntries(this.players), // Send current player list as object
            hostId: this.myPeerId
        };
        console.log(`[WebRTCManager] Sending GAME_INFO to client ${connection.peer}`); // Don't log full payload for brevity
        // console.debug('[WebRTCManager] Game Info Payload:', gameInfoPayload); // Optional full log
        this.sendMessage(connection, MSG_TYPE.GAME_INFO, gameInfoPayload);
    }

    /**
     * [Host Only] Closes connection to a specific client.
     * @param {string} peerId The ID of the client to disconnect.
     */
    closeClientConnection(peerId) {
        if (!this.isHost) return;
        console.log(`[WebRTCManager] Host manually closing connection with client: ${peerId}`);
        this._safelyCloseDataConnection(peerId, DisconnectionReason.MANUAL_HOST_DISCONNECT);
    }

    /**
     * @private Handles cleanup when a client connection is lost or closed.
     * This is triggered BY on('close') or on('error') events, or potentially after a safe close attempt.
     * It should NOT attempt to call connection.close() itself again.
     * @param {string} peerId Client's PeerJS ID.
     * @param {string} [reason='unknown'] - Reason for disconnection.
     */
    _handleClientDisconnection(peerId, reason = DisconnectionReason.UNKNOWN) {
        // Prevent handling if already disconnected or cleanup in progress
        if (!this.players.has(peerId) || !this.connections.has(peerId)) {
            // console.warn(`[WebRTCManager] Attempted to handle disconnection for already removed/unknown peer: ${peerId}. Reason: ${reason}`);
            return;
        }
        const wasOpen = this.connectionStates.get(peerId) === DataConnectionState.OPEN;
        const playerName = this.players.get(peerId)?.name || 'Unknown';

        console.log(`[WebRTCManager] Cleaning up connection for ${playerName} (${peerId}). Reason: ${reason}`);

        // Clean up internal state
        this._removePeerListeners(this.connections.get(peerId)); // Remove listeners first
        this._connectionListeners.delete(peerId); // Remove stored bound listeners
        this.connections.delete(peerId);
        this.connectionStates.set(peerId, DataConnectionState.CLOSED);
        this._clientLastContact.delete(peerId);
        this._removePlayer(peerId); // Removes from this.players and emits PlayerListUpdated

        // Emit specific disconnect event if connection was fully open
        if (wasOpen || reason === DisconnectionReason.TIMEOUT) {
             eventBus.emit(Events.Multiplayer.Host.ClientDisconnected, { peerId, reason });
        }

        // Provide clearer user feedback via event
        let feedbackKey = 'mpClientDisconnectedGeneric'; // Default key
        let feedbackLevel = 'warn';
        if (reason === DisconnectionReason.TIMEOUT) {
            feedbackKey = 'mpClientDisconnectedTimeout';
        } else if (reason === DisconnectionReason.LEFT_VOLUNTARILY) {
            feedbackKey = 'mpClientDisconnectedLeft';
            feedbackLevel = 'info'; // Use info level for voluntary leave
        } else if (reason === DisconnectionReason.SHUTDOWN) {
            // Don't show feedback if host is shutting down normally
            return;
        } else if (reason === DisconnectionReason.SHUTDOWN_CLOSE_ERROR) {
             // Don't show feedback for shutdown errors either (host initiated)
             return;
        }
        const feedbackMessage = miscUtils.getTextTemplate(feedbackKey, { playerName: playerName });
        if (feedbackMessage) {
            eventBus.emit(Events.System.ShowFeedback, { message: feedbackMessage, level: feedbackLevel });
        }
    }
    
    /**
     * Attempts to safely close a DataConnection, checking its state first.
     * @param {string} peerId The peer ID of the connection to close.
     * @param {string} reason The reason for closing (for logging).
     * @private
     */
    _safelyCloseDataConnection(peerId, reason) {
        // +++ ADDED CHECK: Ensure peerId is valid and connection exists +++
        if (!peerId) {
            console.warn(`[WebRTCManager] _safelyCloseDataConnection: Invalid peerId provided. Reason: ${reason}`);
            return; 
        }
        const connection = this.connections.get(peerId);
        // +++ END ADDED CHECK +++

        if (connection) {
            // Check if connection is already closing or closed
            const currentState = this.connectionStates.get(peerId);
            if (currentState === DataConnectionState.CLOSED || currentState === DataConnectionState.CLOSING) {
                console.debug(`[WebRTCManager] _safelyCloseDataConnection: Connection ${peerId} already closed or closing (State: ${currentState}).`);
                // Ensure cleanup still happens if needed
                this._handleClientDisconnection(peerId, reason + DisconnectionReason.ALREADY_CLOSED_SUFFIX);
            return;
        }

            console.log(`[WebRTCManager] _safelyCloseDataConnection: Closing connection with ${peerId}. Reason: ${reason}`);
            this.connectionStates.set(peerId, DataConnectionState.CLOSING);
            try {
                connection.close();
                // The on('close') or on('error') handler will call _handleClientDisconnection for final cleanup.
            } catch (closeError) {
                 // Catch potential errors during close (like the flush error if state is bad)
                 console.warn(`[WebRTCManager] _safelyCloseDataConnection: Error during connection.close() for ${peerId} (Reason: ${reason}). Might be expected if connection was already broken.`, closeError);
                // If close throws, the event handlers might not fire, so trigger cleanup directly.
                this._handleClientDisconnection(peerId, `${reason}_close_error`);
            }
        } else {
             console.warn(`[WebRTCManager] _safelyCloseDataConnection: Attempted to close non-existent connection for peerId: ${peerId}. Reason: ${reason}. (May be expected if already cleaned up)`);
             // Do not trigger cleanup here if connection doesn't exist, it was likely handled already.
        }
    }

    // --- Client Functionality ---

    /**
     * Initializes this peer as a client and attempts to connect to a host using the 6-digit code.
     * @param {string} hostPeerId - The 6-digit code of the host to connect to.
     * @param {string} playerName - This client's chosen name.
     * @throws {Error} If hostPeerId is invalid, already connected, or initialization fails.
     */
    connectToHost(hostPeerId, playerName) {
        console.log(`[WebRTCManager] Attempting to connect to Host (6-digit ID): ${hostPeerId}, Player: ${playerName}`);
        // Basic validation
        if (!/^[0-9]{6}$/.test(hostPeerId)) {
            console.error(`[WebRTCManager] Invalid host ID format: ${hostPeerId}. Must be 6 digits.`);
            eventBus.emit(Events.WebRTC.ConnectionFailed, { error: new Error('Invalid host code format.'), context: 'client-connect-validation' });
            return;
        }
        if (this.status !== ConnectionStatus.DISCONNECTED && this.status !== ConnectionStatus.ERROR) {
             const message = `[WebRTCManager] Cannot connect, current status is ${this.status}. Call closeConnection() first.`;
            console.error(message);
            eventBus.emit(Events.WebRTC.ConnectionFailed, { error: new Error(message), context: 'client-connect-state' });
            return;
        }

        this.resetState();
        this.status = ConnectionStatus.INITIALIZING_PEER; // Use constant
        this.isHost = false;
        this.localPlayerName = playerName || miscUtils.generateRandomPlayerName();
        this.hostId = hostPeerId; // Store the target ID

        try {
            if (typeof Peer === 'undefined') {
                throw new Error(miscUtils.getTextTemplate('rtcErrorPeerJSLoad'));
            }
            // Client uses PeerServer-assigned ID
            this.peer = new Peer({ debug: 2 });

            // Store bound listeners
            this._peerListeners.open = (id) => this._handleClientOpen(id);
            this._peerListeners.error = (err) => this._handleError(err, 'client-peer');
            this._peerListeners.disconnected = () => this._handleDisconnection('client-disconnected-server');
            this._peerListeners.close = () => console.log('[WebRTCManager] Client Peer instance closed.');

            this.peer.on('open', this._peerListeners.open);
            this.peer.on('error', this._peerListeners.error);
            this.peer.on('disconnected', this._peerListeners.disconnected);
            this.peer.on('close', this._peerListeners.close);

        } catch (error) {
            console.error("[WebRTCManager] Error creating client PeerJS instance:", error);
            eventBus.emit(Events.WebRTC.ConnectionFailed, { error, context: 'client-peer-creation' });
            this.status = ConnectionStatus.ERROR; // Use constant
            this.resetState();
        }
        // Add global error listener now that Peer is active
        window.addEventListener('error', this._boundErrorHandler);
        console.debug("[WebRTCManager] Added global error listener (client).");
    }

    /**
     * @private
     * @param {string} id The client PeerJS ID (should match the generated 6-digit code).
     */
    _handleClientOpen(id) {
        // Check if peer object exists and is not destroyed
        if (!this.peer || this.peer.destroyed) {
            console.error("[WebRTCManager] _handleClientOpen called but peer is invalid or destroyed.");
            this._handleError(new Error("Client Peer object invalid during open event"), 'client-peer-open-invalid');
             return;
         }
        // Check if already connected or trying to connect
        if (this.status !== ConnectionStatus.INITIALIZING_PEER) {
            console.warn(`[WebRTCManager] _handleClientOpen called in unexpected state: ${this.status}. Ignoring.`);
            return; 
        }
        
        console.log(`[WebRTCManager] Client PeerJS established. Client ID: ${id}`);
        this.myPeerId = id; // Assign the received client ID
        this._updatePlayer(this.myPeerId, { name: this.localPlayerName, isHost: false });

        // Now that our peer is open, attempt to connect to the target host ID
                     if (!this.hostId) {
             console.error("[WebRTCManager] Critical error: Client Peer opened, but no target hostId is set!");
             this._handleError(new Error("Target host ID missing after client peer open"), 'client-peer-open-no-hostid');
                         return;
                     }
        this._attemptHostConnection(this.hostId); // Trigger the connection to host

        // Do NOT set status or start heartbeats here. Let _attemptHostConnection handle it.
        // eventBus.emit(Events.Multiplayer.Client.ConnectedToHost, { hostId: this.hostId }); // MOVED to _attemptHostConnection's 'open' handler
        // this._startClientPing(); // MOVED to _attemptHostConnection's 'open' handler
        // this._startHostTimeoutCheck(); // MOVED to _attemptHostConnection's 'open' handler
    }

     /**
      * @private
      * @param {string} reason The reason for disconnection ('closed', 'error').
     * @private
      */
    _handleHostDisconnection(reason = DisconnectionReason.UNKNOWN) {
        const hostPeerId = this.hostId; // Store before clearing
        if (!hostPeerId) return; // Already disconnected

        console.log(`[WebRTCManager] Disconnected from host ${hostPeerId}. Reason: ${reason}`);
        this.status = ConnectionStatus.DISCONNECTED; // Or ERROR if reason is 'error'? Let's use DISCONNECTED.

        const connection = this.connections.get(hostPeerId);
        // Remove listeners associated with this connection
        const connListeners = this._connectionListeners.get(hostPeerId);
        if (connection && connListeners) {
            connection.off('open', connListeners.open);
            connection.off('data', connListeners.data);
            connection.off('close', connListeners.close);
            connection.off('error', connListeners.error);
            this._connectionListeners.delete(hostPeerId);
        }

        // Ensure connection is closed
        if (connection && connection.open && reason !== DisconnectionReason.CLOSED_BY_REMOTE) {
            try {
                connection.close();
            } catch (e) {
                console.warn(`[WebRTCManager] Error closing connection with ${hostPeerId}:`, e);
            }
        }
        this.connections.delete(hostPeerId);

        this.hostId = null; // Mark as disconnected from host

        // Don't reset peer, allow potential reconnect attempts by UI/Coordinator
        // Emit DisconnectedFromHost first
        eventBus.emit(Events.Multiplayer.Client.DisconnectedFromHost, { hostId: hostPeerId, reason });
        // Then emit PlayerLeft for game logic
        eventBus.emit(Events.Multiplayer.Common.PlayerLeft, { peerId: hostPeerId });
    }

    // --- Common Functionality ---

    /** Closes all connections and destroys the PeerJS instance. */
    closeConnection() {
        console.log(`[WebRTCManager] Closing connection and destroying PeerJS instance...`);
        this._clearHeartbeatIntervals();

        if (this.connections.size > 0) {
            console.log(`[WebRTCManager] Closing ${this.connections.size} active data connections...`);
            // Get peer IDs before iterating as closing might modify the map
            const peerIdsToClose = Array.from(this.connections.keys()); 
            peerIdsToClose.forEach(peerId => {
                 this._safelyCloseDataConnection(peerId, 'shutdown');
            });
            // Maps are cleared within _handleClientDisconnection triggered by close events/errors
            // Do not clear maps here directly anymore.
            // this.connections.clear();
            // this.connectionStates.clear();
            // this._connectionListeners.clear();
        }

        if (this.peer) {
            console.log("[WebRTCManager] Destroying PeerJS instance...");
            this._removePeerListeners(); // Remove listeners before destroying
            try {
                 if (!this.peer.destroyed) {
                     this.peer.destroy();
                 }
            } catch (destroyError) {
                 // Catch potential errors during destroy (like the flush error if state is bad)
                 console.warn("[WebRTCManager] Error during peer.destroy(). Might be expected if connection was already broken.", destroyError);
            }
            this.peer = null;
        }

        // Reset internal state AFTER cleanup attempts
        this.resetState(); // This clears players map etc.
        console.log("[WebRTCManager] Connection closed and state reset.");
    }

    /** Resets the manager's state variables. */
    resetState() {
        // console.log("[WebRTCManager] Resetting state..."); // Called frequently, maybe make debug level
        this.peer = null;
        this.hostId = null;
        this.myPeerId = null;
        this.connections.clear();
        this.connectionStates.clear();
        this.players.clear();
        this.localPlayerName = miscUtils.generateRandomPlayerName();
        this.isHost = false;
        this.pendingHostGameData = null;
        this.pendingHostDifficulty = null;
        this.status = ConnectionStatus.DISCONNECTED;
         this._peerListeners = {};
         this._connectionListeners.clear();
        this._removePeerListeners(); // Remove listeners before potentially destroying peer
        this._clearHeartbeatIntervals(); // Stop pinging and timeout checks
        this.hostPeerId = null; // Reset the hostPeerId

        // Restore original window.onerror handler - REMOVED logic
        // if (window.onerror === this._boundErrorHandler) {
        //     window.onerror = this._originalOnError;
        //      console.info("[WebRTCManager] Restored original window.onerror handler.");
        // }
        // this._originalOnError = null; // Clear reference

        // Remove our specific event listener
        window.removeEventListener('error', this._boundErrorHandler);
        console.info("[WebRTCManager] Removed global error event listener via resetState.");

        console.info("[WebRTCManager] State reset complete.");
    }

    /**
     * Handles generic PeerJS object errors.
     * @param {Error & { type?: string }} err - The error object.
     * @param {string} [context='general-peer'] - Context where the error occurred.
     * @private
     */
    _handleError(err, context = 'general-peer') {
        console.error(`[WebRTCManager] PeerJS Error (${context}):`, err);
        let message = err.message || 'Unknown PeerJS Error';
        let type = err.type || 'unknown'; // e.g., 'network', 'peer-unavailable', 'server-error', 'webrtc', 'browser-incompatible'

        this.status = ConnectionStatus.ERROR; // Set error state

        // Emit a standardized event
        eventBus.emit(Events.WebRTC.ConnectionFailed, {
            error: err,
            message: `WebRTC Error (${type}): ${message}`,
            context: context,
            peerId: this.myPeerId // Error relates to our peer object
        });

        // Remove listener on fatal peer errors
        window.removeEventListener('error', this._boundErrorHandler);

        // These errors are usually fatal for the peer object, attempt full cleanup
        console.warn(`[WebRTCManager] Attempting full connection cleanup due to Peer error type: ${type}`);
        // DO NOT call closeConnection here. Let the listener (GameCoordinator) handle cleanup based on the emitted event.
    }

    /**
     * Handles peer disconnection from the PeerServer signaling server.
     * @param {string} context - 'host-disconnected-server' or 'client-disconnected-server'.
     * @private
     */
    _handleDisconnection(context) {
         // Ignore if already disconnected or errored
         if (this.status === ConnectionStatus.DISCONNECTED || this.status === ConnectionStatus.ERROR) return;

         console.warn(`[WebRTCManager] Disconnected from PeerServer (${context}). Peer ID: ${this.myPeerId}`);
         this.status = ConnectionStatus.ERROR; // Treat as error

         eventBus.emit(Events.WebRTC.ConnectionFailed, {
             error: new Error('Disconnected from signaling server.'),
             message: 'Lost connection to signaling server.',
             context: context
         });
         // DO NOT call closeConnection here. Let the listener (GameCoordinator) handle cleanup.
    }


    // --- Player List Management ---

    /** @private Adds or updates a player in the local list. */
    _updatePlayer(peerId, playerData) {
        if (!peerId) return;
        // Ensure basic structure
        const dataToSet = {
            name: playerData.name || this.players.get(peerId).name || 'Unknown', // Preserve name if not provided
            isHost: typeof playerData.isHost === 'boolean' ? playerData.isHost : (this.players.get(peerId).isHost ?? false) // Preserve isHost
        };
        this.players.set(peerId, dataToSet);
         console.debug(`[WebRTCManager] Player updated: ${peerId}`, this.players.get(peerId));
    }

     /** @private Removes a player from the local list. */
    _removePlayer(peerId) {
        if (this.players.has(peerId)) {
            this.players.delete(peerId);
            console.debug(`[WebRTCManager] Player removed: ${peerId}`);
        }
    }

    // --- Messaging ---

    /**
     * @param {object} messageData - The PARSED message object.
     * @param {string} senderPeerId - The PeerJS ID of the sender.
     */
    _emitMessageReceived(messageData, senderPeerId) {
        // Data should already be parsed by the 'data' handler
        if (!messageData || typeof messageData !== 'object') {
            console.error(`[WebRTCManager] _emitMessageReceived called with invalid data from ${senderPeerId}:`, messageData);
            return;
        }

        // --- Intercept Heartbeats --- 
        if (messageData.type === MSG_TYPE.PING) {
            // console.log(`[WebRTCManager] Received PING from ${senderPeerId}`);
            if (this.isHost) {
                // Host updates last contact time for this client
                const oldTime = this._clientLastContact.get(senderPeerId);
                this._clientLastContact.set(senderPeerId, Date.now());
                console.log(`[WebRTC DEBUG Host] Updated last contact for ${senderPeerId} due to PING (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
                // *** ADD PONG RESPONSE ***
                const connection = this.connections.get(senderPeerId); 
                if (connection) { 
                    this.sendMessage(connection, MSG_TYPE.PONG, {}); 
                } else {
                    console.warn(`[WebRTC PONG] Could not send PONG to ${senderPeerId}, connection not found.`);
                }
                // *** END PONG RESPONSE ***
            } else {
                // Client received PING from host, update last contact time
                 const oldTime = this._lastHostContact;
                 this._lastHostContact = Date.now();
                 console.log(`[WebRTC DEBUG Client] Updated last contact from host ${senderPeerId} due to PING (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
                // Client could optionally send PONG back
                // this.sendToHost(MSG_TYPE.PONG, {});
            }
            return; // Don't emit PING messages further
        }
        if (messageData.type === MSG_TYPE.PONG) {
            // console.log(`[WebRTCManager] Received PONG from ${senderPeerId}`);
            if (this.isHost) {
                 const oldTime = this._clientLastContact.get(senderPeerId);
                 this._clientLastContact.set(senderPeerId, Date.now());
                 console.log(`[WebRTC DEBUG Host] Updated last contact for ${senderPeerId} due to PONG (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
            } else {
                 const oldTime = this._lastHostContact;
                 this._lastHostContact = Date.now();
                 console.log(`[WebRTC DEBUG Client] Updated last contact from host ${senderPeerId} due to PONG (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
            }
            return; // Don't emit PONG messages further
        }
        // --- End Heartbeat Interception ---

        // --- ADD DEBUG LOG ---
        console.log(`[WebRTCManager._emitMessageReceived] Preparing to emit message from ${senderPeerId}. Type: ${messageData?.type}`);
        // --- END DEBUG LOG ---

        // --- Update Last Contact on ANY message ---
        // The last contact time is now primarily updated in the 'data' handler (for host)
        // or the 'data' handler (for client) *before* calling this function.
        // However, we still need to update it here for PONG messages (since they return early above)
        // and potentially other internal message types if they were handled directly in `data`.
        // Let's keep the update logic here as a fallback/for clarity, even if redundant for most messages now.
        if (this.isHost) {
             const oldTime = this._clientLastContact.get(senderPeerId);
             // Only update if PING/PONG didn't already (or if it wasn't updated in 'data' handler - safety)
             if (messageData.type !== MSG_TYPE.PING && messageData.type !== MSG_TYPE.PONG) {
                 this._clientLastContact.set(senderPeerId, Date.now());
                 console.log(`[WebRTC DEBUG Host - emit] Updated last contact for ${senderPeerId} due to MSG Type '${messageData?.type}' (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
             }
        } else if (senderPeerId === this.hostId) { // Only update for messages from the host
             const oldTime = this._lastHostContact;
             // Only update if PING/PONG didn't already
             if (messageData.type !== MSG_TYPE.PING && messageData.type !== MSG_TYPE.PONG) {
                this._lastHostContact = Date.now();
                console.log(`[WebRTC DEBUG Client - emit] Updated last contact from host ${senderPeerId} due to MSG Type '${messageData?.type}' (Old: ${oldTime ? new Date(oldTime).toLocaleTimeString() : 'None'}, New: ${new Date(Date.now()).toLocaleTimeString()})`);
             }
        }
        // --- End Last Contact Update ---

        // Emit the PARSED data object
        console.debug(`[WebRTCManager] Emitting WebRTC.MessageReceived from ${senderPeerId}:`, messageData);
        eventBus.emit(Events.WebRTC.MessageReceived, { msg: messageData, sender: senderPeerId });
    }


    /**
     * Sends a message object to a specific peer via a connection.
     * Ensures the payload is stringified.
     * @param {DataConnection} connection - The PeerJS DataConnection.
     * @param {string} type - The message type (e.g., 'game_start').
     * @param {object} [payload={}] - The data payload.
     */
    sendMessage(connection, type, payload = {}) {
        if (!connection) {
             console.warn(`[WebRTCManager] Cannot send message: connection object is null/undefined.`);
             return;
        }
         if (connection.open) {
            const message = { type, payload };
            // Debug specific message types
            if (type === MSG_TYPE.PING) {
                 console.log(`[WebRTC Send PING] Attempting to send PING to ${connection.peer}`);
            } else if (type === MSG_TYPE.CLIENT_READY) {
                 console.log(`[WebRTC Send CLIENT_READY] Sending CLIENT_READY to ${connection.peer} with payload:`, payload);
            }
            
            try {
                 // PeerJS handles serialization, but stringify explicitly for safety/consistency
                 connection.send(message); // Send the object directly
                 
                 // Log confirmation for important messages
                 if (type === MSG_TYPE.CLIENT_READY) {
                     console.log(`[WebRTC Send CLIENT_READY] Successfully sent CLIENT_READY message to ${connection.peer}`);
                 }
            } catch (error) {
                 console.error(`[WebRTCManager] Error sending message to ${connection.peer}:`, error, message);
                  // --- Resilience Check for Broken Connection State --- 
                  const isFlushError = (error instanceof TypeError && error.message.includes("Cannot read properties of undefined (reading 'flush')"));
                  const isInvalidState = (error.name === 'InvalidStateError'); // Common when channel closed unexpectedly

                  if (isFlushError || isInvalidState) {
                       console.warn(`[WebRTCManager] Attempted to send on likely broken/closed channel to ${connection.peer}. Triggering proactive safe close.`);
                       // Attempt safe closure first instead of immediate full disconnect
                       this._safelyCloseDataConnection(connection, 'broken-connection-on-send');
                       // IMPORTANT: Do not proceed to emit ConnectionFailed for this specific case,
                       // as _safelyCloseDataConnection might handle or trigger the necessary events.
                   } else {
                        // For other unexpected send errors, emit a general failure
                 eventBus.emit(Events.WebRTC.ConnectionFailed, { error: error, peerId: connection.peer, context: 'send-message-error', message: `Failed to send message type ${type}` });
                   }
            }
        } else {
            console.warn(`[WebRTCManager] Cannot send message type ${type}, connection to ${connection.peer} is not open.`);
            // Optional: Queue message or emit failure? For now, just warn.
        }
    }

    /** [Host Only] Sends a message object to all connected clients. */
    broadcastMessage(type, payload = {}) {
        if (!this.isHost) {
             console.warn("[WebRTCManager] broadcastMessage called, but not host.");
             return;
        }
        // *** MODIFIED DEBUG LOGGING ***
        console.log(`[WebRTC Broadcast ${type}] Broadcasting to ${this.connections.size} connection(s).`); 
        // *** END MODIFIED DEBUG LOGGING ***
        this.connections.forEach((conn) => { // No need for peerId here
            // *** ADDED DEBUG LOGGING ***
            console.log(`[WebRTC Broadcast ${type}] Sending to peer: ${conn.peer}`);
            // *** END ADDED DEBUG LOGGING ***
            this.sendMessage(conn, type, payload);
        });
    }

     /**
      * Sends a message to the host (used by client).
      * Ensures the instance is a client and connected before sending.
      * @param {string} type - The message type.
      * @param {object} payload - The message payload.
      * @throws {Error} If not connected as a client or connection is not open.
      */
    sendToHost(type, payload = {}) {
        if (this.isHost) {
            console.error("[WebRTCManager] sendToHost called, but this instance is the host.");
            throw new Error("Cannot send to host from host instance.");
        }
        // Use hostId (the 6-digit code) which is the key for the connection map
        if (!this.hostId) {
             console.error("[WebRTCManager] sendToHost called, but not connected to any host.");
            throw new Error("Not connected to host.");
        }
        const hostConnection = this.connections.get(this.hostId);
        // Check state using hostId as well
        if (hostConnection && this.connectionStates.get(this.hostId) === DataConnectionState.OPEN) {
            // console.log(`[WebRTCManager] Sending to Host (${this.hostId}): Type=${type}`, payload);
            try {
                 // Call the internal sendMessage method for consistency and error handling
            this.sendMessage(hostConnection, type, payload);
            } catch (error) {
                 // sendMessage has its own catch block, but add one here just in case sendMessage itself throws
                 console.error(`[WebRTCManager] Unexpected error calling sendMessage within sendToHost for host ${this.hostId}:`, error);
             }
        } else {
             console.error(`[WebRTCManager] sendToHost failed: Connection to host ${this.hostId} not open or not found. State: ${this.connectionStates.get(this.hostId)}`);
            throw new Error(`Connection to host ${this.hostId} is not open.`);
        }
    }

    // --- Getters ---
    getPlayerList() {
        return new Map(this.players); // Return a copy
    }

    getMyPeerId() {
        return this.myPeerId;
    }

     getIsHost() {
         return this.isHost;
     }

     /** Gets the current connection status. */
     getStatus() {
         return this.status;
     }

     /** Gets the ID of the host (if client and connected). */
     getHostId() {
         return this.hostId;
     }

     /** Gets IDs of all currently connected peers (clients for host, host for client). */
     getConnectedPeerIds() {
         return Array.from(this.connections.keys());
     }

    /**
     * DEBUG: Logs detailed information about the current player list
     * and connection state. Useful for troubleshooting issues.
     */
    getConnectedPlayers() {
        return new Map(this.players);
    }

    // --- Heartbeat and Timeout Methods ---

    /** [Host Only] Starts broadcasting PING messages to all connected clients. @private */
    _startHostHeartbeatBroadcast() {
        this._clearHeartbeatIntervals(); // Clear previous if any
        console.log(`[${this.constructor.name} Host] Starting PING broadcast interval.`);
        this._pingIntervalId = setInterval(() => {
            // +++ ADDED DEBUG LOG +++
            console.log(`[WebRTCManager Host PING Interval] Tick. Status: ${this.status}, Connections: ${this.connections.size}`);
            // +++ END ADDED DEBUG LOG +++
            if (this.status === ConnectionStatus.AWAITING_CONNECTIONS || this.status === ConnectionStatus.CONNECTED_HOST) {
                 // +++ ADDED DEBUG LOG +++
                 console.log(`[WebRTCManager Host PING Interval] Status OK, attempting broadcast.`);
                 // +++ END ADDED DEBUG LOG +++
                 this.broadcastMessage(MSG_TYPE.PING, {});
            }
        }, HEARTBEAT_INTERVAL_MS);
    }

    /** [Host Only] Starts checking for client timeouts. @private */
    _startClientTimeoutCheck() {
        this._clearHeartbeatIntervals(); // Clear previous if any
        console.log(`[${this.constructor.name} Host] Starting client timeout check interval.`);
        this._timeoutCheckIntervalId = setInterval(() => {
            const now = Date.now();
            this._clientLastContact.forEach((lastContactTime, peerId) => {
                if (now - lastContactTime > TIMEOUT_MS) {
                    console.warn(`[WebRTCManager Host] Client ${peerId} timed out (Last contact: ${new Date(lastContactTime).toLocaleTimeString()}). Triggering cleanup.`);
                    this._handleClientDisconnection(peerId, DisconnectionReason.TIMEOUT);
                }
            });
        }, HEARTBEAT_INTERVAL_MS); // Check every heartbeat interval
    }

    /** [Client Only] Starts sending PING messages to the host. @private */
    _startClientPing() {
        if (this.isHost || this._pingIntervalId) return; // Only run on client, only start once

        console.log("[WebRTCManager Client] Starting PING interval to host.");
        this._pingIntervalId = setInterval(() => {

             if (this.status === ConnectionStatus.CONNECTED_CLIENT && this.hostId) {
                
              //  console.log(`[WebRTCManager Client PING Interval] Status OK, attempting send to host ${this.hostId}.`);
                this.sendToHost(MSG_TYPE.PING, {}); // Send PING message type
            } else {
                // console.debug("[WebRTCManager Client] Skipping PING (not connected).");
             }
        }, HEARTBEAT_INTERVAL_MS);
    }

    /** [Client Only] Starts checking for host timeout. @private */
    _startHostTimeoutCheck() {
        if (this.isHost || this._timeoutCheckIntervalId) return;
        console.log("[WebRTCManager Client] Starting host timeout check interval.");
        // Clear previous interval if any (safety)
        if (this._timeoutCheckIntervalId) clearInterval(this._timeoutCheckIntervalId);
        // Initialize contact time
        this._lastHostContact = Date.now();

        this._timeoutCheckIntervalId = setInterval(() => {
             if (this.status === ConnectionStatus.CONNECTED_CLIENT) {
                 const now = Date.now();
                 if (now - this._lastHostContact > TIMEOUT_MS) {
                     console.warn(`[WebRTCManager Client] Host timed out (Last contact: ${new Date(this._lastHostContact).toLocaleTimeString()}). Disconnecting.`);
                     this._handleHostDisconnection(DisconnectionReason.TIMEOUT);
                 }
             }
        }, HEARTBEAT_INTERVAL_MS); // Check interval
    }

    /** [Client Only] Pauses the host timeout check interval. */
    pauseHostTimeoutCheck() {
        if (!this.isHost && this._timeoutCheckIntervalId) {
            console.log("[WebRTCManager Client] Pausing host timeout check.");
            clearInterval(this._timeoutCheckIntervalId);
            this._timeoutCheckIntervalId = null;
        }
    }

    /** [Client Only] Resumes the host timeout check interval if paused. */
    resumeHostTimeoutCheck() {
        if (!this.isHost || this.status !== ConnectionStatus.CONNECTED || !this.hostId) return;
        console.log("[WebRTCManager Client] Resuming host timeout check.");
        this._startHostTimeoutCheck(); // Restart the interval
    }

    /**
     * Stops the client-side interval checking for host timeout.
     */
    stopTimeoutCheck() {
        if (this._timeoutCheckIntervalId) {
            console.log("[WebRTCManager] Stopping timeout check interval.");
            clearInterval(this._timeoutCheckIntervalId);
            this._timeoutCheckIntervalId = null;
        }
    }

    /** @private */
    _removePeerListeners() {
        if (this.peer && this._peerListeners.open) {
            Object.entries(this._peerListeners).forEach(([event, listener]) => {
                if (listener) {
                    this.peer.off(event, listener);
                }
            });
            this._peerListeners = {}; // Clear stored listeners
            console.debug("[WebRTCManager] Removed PeerJS listeners.");
        }
    }

    /** @private */
    _clearHeartbeatIntervals() {
        console.log("[WebRTCManager] Clearing heartbeat/timeout intervals.");
        if (this._pingIntervalId) {
            clearInterval(this._pingIntervalId);
            this._pingIntervalId = null;
        }
        if (this._timeoutCheckIntervalId) {
            clearInterval(this._timeoutCheckIntervalId);
            this._timeoutCheckIntervalId = null;
        }
        this._clientLastContact.clear();
        this._lastHostContact = null;
    }

    /**
     * Sends a message to a specific peer (used by host).
     * @param {string} targetPeerId - The PeerJS ID of the recipient.
     * @param {string} type - The message type (e.g., GAME_START).
     * @param {object} payload - The message payload.
     */
    sendToPeer(targetPeerId, type, payload = {}) {
        if (!this.connections || !this.connections.has(targetPeerId)) {
            console.warn(`[WebRTCManager] sendToPeer: No connection found for targetPeerId: ${targetPeerId}. Ignoring.`);
            return;
        }
        const connection = this.connections.get(targetPeerId);
        
        // *** ADDED: try...catch around sendMessage ***
        try {
            // Check if connection exists and appears open before attempting send
            if (connection && connection.open) { 
            this.sendMessage(connection, type, payload);
        } else {
                console.warn(`[WebRTCManager] sendToPeer: Connection to ${targetPeerId} not open or ready. State: ${connection?.readyState}. Ignoring send.`);
                // Optionally trigger cleanup if connection is unexpectedly closed
                if (connection && connection.readyState !== 'connecting' && connection.readyState !== 'open') {
                    this._handleClientDisconnection(targetPeerId, 'send_fail_not_open');
                }
            }
        } catch (error) {
            console.error(`[WebRTCManager] sendToPeer: Error sending message to ${targetPeerId}. Type: ${type}. Error:`, error);
            // Attempt cleanup for the problematic connection
            this._handleClientDisconnection(targetPeerId, 'send_fail_exception'); 
        }
        // *** END try...catch ***
    }

    /**
     * Initiates the data connection to the specified host ID.
     * Sets up listeners for the connection lifecycle.
     * @param {string} targetHostId The 6-digit host ID to connect to.
     * @private
     */
    _attemptHostConnection(targetHostId) {
         if (this.status !== ConnectionStatus.INITIALIZING_PEER || !this.peer) {
             console.error("[WebRTCManager] Cannot attempt host connection, invalid state or PeerJS not ready.");
             this.status = ConnectionStatus.ERROR;
             this._handleError(new Error("Attempted connection with invalid state/peer"), 'client-attempt-invalid-state');
             return;
         }
         console.log(`[WebRTCManager] Attempting to connect to host ${targetHostId} (using 6-digit ID)...`);
         this.status = ConnectionStatus.CONNECTING_TO_HOST;

        try {
             // Use the stored player name for the initial (but unused by host) metadata
             // Host relies on the 'client_hello' message instead.
             const conn = this.peer.connect(targetHostId, {
                 reliable: true,
                 // metadata: { name: this.localPlayerName } // Metadata less critical now
             });

             console.log(`[WebRTC Client] Created connection object for host ${targetHostId}:`, conn);

             if (!conn) {
                  throw new Error("Peer.connect() returned undefined. Host ID likely invalid or PeerServer issue.");
             }

              this.status = ConnectionStatus.CONNECTION_PENDING;
              this.connections.set(targetHostId, conn);
              this.connectionStates.set(targetHostId, DataConnectionState.OPENING);

              // Setup listeners for this specific connection
              const connListeners = {
                  open: () => {
                      if (this.status !== ConnectionStatus.CONNECTION_PENDING) {
                           console.warn(`[WebRTCManager] Host connection 'open' event received in unexpected state: ${this.status}.`);
                           return;
                      }
                      if (!this.hostId) {
                          console.error("[WebRTCManager] Critical error: Connection opened but hostId is not set!");
                          this._handleHostDisconnection(DisconnectionReason.INTERNAL_ERROR);
                          return;
                      }
                      console.log(`[WebRTCManager] Data connection opened with host: ${targetHostId}`);
                      this.status = ConnectionStatus.CONNECTED_CLIENT;
                      this.connectionStates.set(this.hostId, DataConnectionState.OPEN);
                      this.hostPeerId = targetHostId; // Store the actual host ID we connected to

                      // Send explicit hello message with name
                      console.log(`[WebRTC Client] Sending client_hello with name: ${this.localPlayerName}`);
                      this.sendMessage(conn, 'client_hello', { name: this.localPlayerName });

                      // Emit connection success event and start heartbeats
                      eventBus.emit(Events.Multiplayer.Client.ConnectedToHost, { hostId: targetHostId });
                      this._startClientPing();
                      this._startHostTimeoutCheck();
                  },
                  data: (rawData) => {
                      const senderPeerId = targetHostId; // For client, sender is always the host
                       // Wrap the entire handler content in a try-catch for robustness
                      try {
                           console.log(`%c[WebRTC RAW Client] Received data from host ${senderPeerId}:`, 'color: orange; font-weight: bold;', rawData);
                          let messageData;
                          try {
                              if (typeof rawData === 'string') {
                                  messageData = JSON.parse(rawData);
                              } else if (typeof rawData === 'object' && rawData !== null) {
                                  messageData = rawData;
                              } else {
                                  console.error(`[WebRTCManager Client] Received unexpected data type from ${senderPeerId}: ${typeof rawData}`, rawData);
                                  return; // Ignore unexpected types
                              }
                          } catch (parseError) {
                               console.error(`[WebRTCManager Client] Failed to parse message JSON string in 'data' handler from ${senderPeerId}:`, parseError, rawData);
                              this._handleHostDisconnection(DisconnectionReason.MESSAGE_PARSE_ERROR);
                              return; // Stop processing if string parsing fails
                          }
                           // Update last contact time immediately after receiving/parsing any valid data structure
                           this._lastHostContact = Date.now();
                           console.log(`[WebRTC DEBUG Client] Updated last contact for host ${senderPeerId} at start of data handler (Time: ${new Date().toLocaleTimeString()})`);

                           // Pass the PARSED/validated data to the emit handler
                           this._emitMessageReceived(messageData, senderPeerId);
                      } catch(outerError) {
                           console.error(`[WebRTCManager Client] Unexpected error in host 'data' handler:`, outerError);
                           this._handleHostDisconnection(DisconnectionReason.DATA_HANDLER_ERROR);
                      }
                  },
                  close: () => this._handleHostDisconnection(DisconnectionReason.CLOSED_BY_REMOTE),
                  error: (err) => {
                      console.warn(`[WebRTCManager] Connection error with host ${targetHostId}:`, err);
                       // Specific error for unavailable peer ID
                      if (err.type === 'peer-unavailable') {
                           console.error(`[WebRTCManager] Host ID ${targetHostId} not found on PeerServer.`);
                           eventBus.emit(Events.WebRTC.ConnectionFailed, { error: err, peerId: targetHostId, context: 'client-connect-not-found', message: miscUtils.getTextTemplate('rtcErrorHostNotFound') });
                           this._handleHostDisconnection(DisconnectionReason.PEER_UNAVAILABLE);
                      } else {
                           eventBus.emit(Events.WebRTC.ConnectionFailed, { error: err, peerId: targetHostId, context: 'client-conn-error', message: err.message });
                           this._handleHostDisconnection(DisconnectionReason.CONNECTION_ERROR);
                      }
                  }
              };
              this._connectionListeners.set(targetHostId, connListeners);

              conn.on('open', connListeners.open);
              conn.on('data', connListeners.data);
              conn.on('close', connListeners.close);
              conn.on('error', connListeners.error);

         } catch (error) {
              console.error(`[WebRTCManager] Failed to initiate connection to host ${targetHostId}:`, error);
              eventBus.emit(Events.WebRTC.ConnectionFailed, { error, peerId: targetHostId, context: 'client-connect-initiate', message: error.message });
              this.status = ConnectionStatus.ERROR;
         }
    }
}


// --- Singleton Instance ---
const webRTCManager = new WebRTCManager();
// Ensure PeerJS is loaded before initialization attempts if using global script
// Consider adding a check or delay if needed.
export default webRTCManager; import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';
import { getTextTemplate } from '../utils/miscUtils.js';


// Add V1 constants
const STORAGE_KEY_PREFIX = "unicornpoep_highscore_";
const MAX_ENTRIES_PER_SHEET = 20;

/**
 * Manages loading, saving, and retrieving highscores from localStorage
 * using the v1 multi-key approach (one key per sheet/difficulty).
 * This service is called by coordinators (e.g., UIManager, GameCoordinator)
 * in response to application events. It does not listen for events itself.
 */
class HighscoreManager {
    constructor() {
        console.info("[HighscoreManager] Initializing (V1 Multi-Key Storage Service)...");
    }

    /**
     * Generates a unique key for storing scores based on sheet and difficulty.
     * Sanitizes and truncates the key for safety.
     * Mirrors the v1 logic precisely.
     * @param {string} sheetKey - Combined sheet names (e.g., 'Tafel van 2,Tafel van 3').
     * @param {string|null} difficulty - Difficulty level ('easy', 'medium', 'hard') or null for practice.
     * @returns {string} The localStorage key.
     * @private
     */
    _getStorageKey(sheetKey, difficulty) {
        const diffSuffix = difficulty ? `_${difficulty}` : '_practice';
        // Sanitize: Replace non-alphanumeric (allow ,-_) with _, lowercase
        const safeSheetKey = (sheetKey || 'unknown').replace(/[^a-z0-9,\-_]/gi, '_').toLowerCase();
        // Truncate to prevent excessively long keys - match V1 exactly
        const truncatedKey = safeSheetKey.length > 50 ? safeSheetKey.substring(0, 50) : safeSheetKey;
        return `${STORAGE_KEY_PREFIX}${truncatedKey}${diffSuffix}`;
    }

    /**
     * Retrieves scores for a specific game configuration synchronously from localStorage.
     * Handles potential JSON parsing errors. Mirrors v1 logic.
     * @param {string} sheetKey - The identifier for the sheets played.
     * @param {string|null} difficulty - The difficulty level.
     * @param {string} mode - The game mode ('single', 'multiplayer', 'practice').
     * @returns {Array<object>} An array of score objects, empty if error or not found.
     * @private
     */
    _getScoresForSheetSync(sheetKey, difficulty, mode) {
        let storageKey;
        if (mode === 'single') {
            storageKey = this._getSinglePlayerStorageKeyV1(sheetKey);
        } else {
            storageKey = this._getStorageKey(sheetKey, difficulty);
        }

        try {
            const storedData = localStorage.getItem(storageKey);
            if (!storedData) return []; // No data found

            const parsed = JSON.parse(storedData);
            // Ensure the parsed data is actually an array and validate basic structure
            if (Array.isArray(parsed) && parsed.every(s => typeof s === 'object' && s !== null && 'player' in s && 'score' in s)) {
                // Map to ensure consistent structure, deriving gameName for single player V1 entries
                return parsed.map(score => ({
                    player: score.player,
                    score: score.score,
                    date: score.date, // Pass date as is
                    // V1: gameName exists only in multi entries. For single, use sheetKey.
                    gameName: score.gameName || sheetKey,
                    mode: score.mode || (mode === 'single' ? 'Single Player' : 'Multi'), // Infer mode if missing based on key type
                    difficulty: score.difficulty || difficulty || '-', // Map difficulty
                }));
            } else {
                 console.warn(`[HighscoreManager] Invalid data format (not a valid score array) for key ${storageKey}. Removing.`);
                 localStorage.removeItem(storageKey);
                 return [];
            }
        } catch (error) {
            console.error(`[HighscoreManager] Error retrieving or parsing sync scores from ${storageKey}:`, error);
            // If parsing fails, assume data is corrupt and remove it
            localStorage.removeItem(storageKey);
            return [];
        }
    }

    /**
     * Generates the V1-style key for single-player scores.
     * @param {string} sheetKey - The sheet name(s).
     * @returns {string} The localStorage key.
     * @private
     */
    _getSinglePlayerStorageKeyV1(sheetKey) {
        // V1 simple prefix + sheet key
        const safeSheetKey = (sheetKey || 'unknown').replace(/[^a-z0-9,\-_ ]/gi, '_'); // Allow spaces as per V1 example 'Tafel van 3'
        return `highscores_${safeSheetKey}`;
    }

    /**
     * Adds a new score entry for a specific game configuration.
     * Saves to the specific localStorage key for the sheet/difficulty.
     * @param {string} playerName - Player's name.
     * @param {number} score - Score achieved.
     * @param {string} sheetKey - Identifier for the sheets played (e.g., 'Tafel van 2,Tafel van 3').
     * @param {string} mode - Game mode ('single', 'multiplayer', 'practice'). Note: V1 used 'Single Player'/'Multi'
     * @param {string|null} difficulty - Difficulty level ('easy', 'medium', 'hard') or null for practice.
     * @returns {boolean} True if the score qualified and was saved, false otherwise.
     */
    addHighscore(playerName, score, sheetKey, mode, difficulty) {
        // Prevent saving scores for practice mode or non-positive scores
        if (mode === 'practice' || !difficulty || score <= 0) {
            console.log("[HighscoreManager] Skipping score save (practice mode, no difficulty, or zero/negative score).");
            return false; // Score didn't qualify or shouldn't be saved
        }

        // Basic validation
        if (typeof playerName !== 'string' || typeof score !== 'number' || !sheetKey || !mode) {
            console.warn(`[HighscoreManager] Invalid score attempt: Missing data. Player='${playerName}', Score=${score}, Sheet='${sheetKey}', Mode='${mode}', Diff='${difficulty}'`);
            return false;
        }

        let storageKey;
        if (mode === 'single') {
            storageKey = this._getSinglePlayerStorageKeyV1(sheetKey);
        } else if (mode === 'multiplayer') {
            // Existing logic for multiplayer/practice keys
            storageKey = this._getStorageKey(sheetKey, difficulty);
        } else {
            // Practice mode saving is already skipped earlier, but handle defensively
            console.warn("[HighscoreManager] Attempted to save score for unexpected mode:", mode);
            return false;
        }

        const timestamp = new Date().toISOString();

        // --- FIX: Normalize sheetKey format before using it --- 
        let normalizedSheetKey = (sheetKey || 'Unknown Game').replace(/_/g, ':'); // Replace all underscores with colons
        // Handle cases with multiple sheets joined by ", " - normalize each part
        if (normalizedSheetKey.includes(', ')) {
            normalizedSheetKey = normalizedSheetKey.split(', ')
                                             .map(part => part.replace(/_/g, ':'))
                                             .join(', ');
        }
        // --- END FIX ---

        // Format gameName according to V1 screenshot example - now uses normalized key
        let formattedGameName = normalizedSheetKey; // Start with the normalized sheet key
        if (mode === 'multiplayer' && difficulty) {
            // Capitalize difficulty for display
            const difficultyDisplay = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
            formattedGameName = `${normalizedSheetKey} (Multiplayer ${difficultyDisplay})`; // Use normalized key here too
        } else if (mode === 'single') {
            // V1 examples just show the sheet name for single player
            // formattedGameName = sheetKey; // Already set
        }
        // Handle potential practice mode display if needed, although V1 didn't save these usually

        // Construct the entry matching V1 structure more closely
        const entry = {
            player: playerName,
            score: score,
            date: timestamp,
            // Store the raw mode/difficulty internally if needed, but gameName is primary for V1 display
            mode: mode === 'single' ? 'Single Player' : (mode === 'multiplayer' ? 'Multi' : 'Practice'),
            difficulty: difficulty // Store the raw difficulty string
        };

        // *** V1 Alignment: ONLY add gameName for multiplayer games ***
        if (mode === 'multiplayer') {
            entry.gameName = formattedGameName;
        }

        try {
            // 1. Load scores for the specific sheet/difficulty
            const currentScores = this._getScoresForSheetSync(sheetKey, difficulty, mode);

            // 2. Check if it qualifies (top N or list not full)
            if (currentScores.length < MAX_ENTRIES_PER_SHEET || score > (currentScores[currentScores.length - 1]?.score || 0)) {

                // 3. Add the new score
                currentScores.push(entry);

                // 4. Sort descending by score, then ascending by date for ties (mirror V1)
                currentScores.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    const dateA = new Date(a.date); const dateB = new Date(b.date);
                    // Handle potential invalid dates during sort
                    return (!isNaN(dateA) && !isNaN(dateB)) ? dateA - dateB : 0;
                });

                // 5. Keep only top N entries
                const updatedScores = currentScores.slice(0, MAX_ENTRIES_PER_SHEET);

                // 6. Save back to the specific key
                localStorage.setItem(storageKey, JSON.stringify(updatedScores));
                console.log(`[HighscoreManager] Score saved to V1-compatible key: ${storageKey}`);
                return true; // Score was added and saved

            } else {
                 console.log(`[HighscoreManager] Score ${score} by ${playerName} for ${sheetKey} (${difficulty}) not high enough.`);
                 return false; // Score did not qualify
            }
        } catch (error) {
            console.error(`[HighscoreManager] Error saving score to ${storageKey}:`, error);
            eventBus.emit(Events.System.ShowFeedback, { message: getTextTemplate('hsSaveError'), level: 'error' });
            return false; // Error occurred
        }
    }

    /**
     * Retrieves all scores from localStorage across all relevant V1 keys.
     * Handles potential JSON parsing errors for individual keys.
     * @returns {Array<object>} An array of all score objects, sorted globally by score descending.
     * @private
     */
    _getAllScoresFromStorage() {
        let allScores = [];
        try {
            const keys = Object.keys(localStorage);
            for (const key of keys) {
                // Check if key matches EITHER V1 single-player OR V1 multiplayer prefix
                if (key.startsWith(STORAGE_KEY_PREFIX) || key.startsWith('highscores_')) {
                    const storedData = localStorage.getItem(key);
                    if (storedData) {
                        try {
                            const sheetScores = JSON.parse(storedData);
                            if (Array.isArray(sheetScores) && sheetScores.every(s => typeof s === 'object' && s !== null && 'player' in s && 'score' in s)) {
                                // Map to ensure consistent structure expected by the component
                                const mappedScores = sheetScores.map(score => {
                                    let gameNameFallback = 'Unknown';
                                    if (key.startsWith('highscores_')) {
                                        // For single-player keys, the game name is derived directly from the key
                                        gameNameFallback = key.substring('highscores_'.length);
                                    } else if (key.startsWith(STORAGE_KEY_PREFIX)) {
                                        // For multiplayer keys, try extracting from the key if gameName isn't stored (should be rare)
                                        gameNameFallback = this._extractSheetKeyFromStorageKey(key) || 'Unknown';
                                    }

                                    return {
                                        player: score.player,
                                        score: score.score,
                                        date: score.date, // Pass date as is
                                        // Use stored gameName if present (V1 multi), otherwise use the derived fallback (V1 single/corner cases)
                                        gameName: score.gameName || gameNameFallback,
                                        // Mode/difficulty might not be stored reliably in V1 single-player entries
                                        mode: score.mode || (key.startsWith('highscores_') ? 'Single Player' : '-'), // Infer mode if missing
                                        difficulty: score.difficulty || this._extractDifficultyFromStorageKey(key) || '-', // Difficulty mostly from multi keys
                                    };
                                });
                                allScores = allScores.concat(mappedScores);
                            } else {
                                 console.warn(`[HighscoreManager] Invalid data format (not a valid score array) for key ${key}. Removing.`);
                                 localStorage.removeItem(key);
                            }
                        } catch (parseError) {
                            console.warn(`[HighscoreManager] Failed to parse scores for key ${key}. Removing.`, parseError);
                            localStorage.removeItem(key); // Remove corrupted data
                        }
                    }
                }
            }
            // Sort all collected scores globally by score descending
            allScores.sort((a, b) => b.score - a.score);
            return allScores;
        } catch (error) {
            // Catch potential errors during key iteration (less likely)
            console.error("[HighscoreManager] Error retrieving all scores:", error);
            return []; // Return empty array on major error
        }
    }

    /**
     * Helper to try and extract the original sheet key part from a storage key.
     * @param {string} storageKey - The full localStorage key.
     * @returns {string|null} The extracted sheet key or null.
     * @private
     */
    _extractSheetKeyFromStorageKey(storageKey) {
        if (!storageKey || !storageKey.startsWith(STORAGE_KEY_PREFIX)) return null;
        const base = storageKey.substring(STORAGE_KEY_PREFIX.length);
        const difficultyParts = ['_easy', '_medium', '_hard', '_practice'];
        for (const suffix of difficultyParts) {
            if (base.endsWith(suffix)) {
                return base.substring(0, base.length - suffix.length);
            }
        }
        // If no known difficulty suffix, return the whole base part (might be practice w/o suffix?)
        return base;
    }

    /**
     * Helper to try and extract the difficulty part from a storage key.
     * @param {string} storageKey - The full localStorage key.
     * @returns {string|null} The extracted difficulty or null.
     * @private
     */
     _extractDifficultyFromStorageKey(storageKey) {
        if (!storageKey) return null;
        if (storageKey.endsWith('_easy')) return 'easy';
        if (storageKey.endsWith('_medium')) return 'medium';
        if (storageKey.endsWith('_hard')) return 'hard';
        if (storageKey.endsWith('_practice')) return 'practice'; // Or null/N/A depending on preference
        return null; // No difficulty suffix found
    }

    /**
     * Checks if a given score qualifies as a new highscore for the specified sheet/difficulty.
     * Mirrors V1 logic.
     * @param {string} sheetKey - The identifier for the sheets played.
     * @param {string|null} difficulty - The difficulty level.
     * @param {number} score - The score to check.
     * @returns {boolean} True if the score is a new highscore, false otherwise.
     */
     isNewHighScore(sheetKey, difficulty, score) {
        // Practice mode doesn't have highscores handled here, and score must be positive
        if (!difficulty || score <= 0) {
            return false;
        }

        try {
            const currentScores = this._getScoresForSheetSync(sheetKey, difficulty, 'multiplayer');

            // If the list isn't full, any positive score qualifies
            if (currentScores.length < MAX_ENTRIES_PER_SHEET) {
                return true;
            }

            // If the list is full, check against the lowest score
            // Use nullish coalescing for safety in case the last entry is malformed (though validation should prevent this)
            const lowestScore = currentScores[currentScores.length - 1]?.score ?? 0;
            return score > lowestScore;

        } catch (error) {
            console.error(`[HighscoreManager] Error checking for new highscore for ${sheetKey} (${difficulty}):`, error);
            return false; // Fail safe: assume not a highscore on error
        }
    }

    /**
     * Loads all V1 highscores from localStorage, sorts them, and emits
     * the result via the event bus. Intended to be called by a coordinator
     * (e.g., UIManager) when the highscores view is requested.
     * Emits Events.Menu.Highscores.Loaded on success, LoadFailed on error.
     */
    loadAndEmitAllScores() {
        console.log("[HighscoreManager] loadAndEmitAllScores called (V1 mode).");
        try {
             // Load scores using the V1-compatible multi-key method
             const allScores = this._getAllScoresFromStorage(); // Use the existing private method
             console.log(`[HighscoreManager] Emitting ${allScores.length} total scores from V1-compatible storage for display.`);
             eventBus.emit(Events.Menu.Highscores.Loaded, { scores: allScores });
        } catch (error) {
             console.error("[HighscoreManager] Error loading scores for display:", error);
             eventBus.emit(Events.Menu.Highscores.LoadFailed, { message: getTextTemplate('hsLoadErrorGeneric') });
        }
    }

}

// Create and export a singleton instance
const highscoreManager = new HighscoreManager();
export default highscoreManager;
import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';
// Import QuestionsManager
import questionsManager from './QuestionsManager.js';
import arrayUtils from '../utils/arrayUtils.js'; // Changed to default import
import { getTextTemplate } from '../utils/miscUtils.js'; // Import the utility
// REMOVED: Incorrect import
// import { DIFFICULTY_DURATIONS_MS } from '../core/game-constants.js';

/**
 * @typedef {object} Question
 * @property {string} question - The question text.
 * @property {string} answer - The correct answer text.
 * @property {string[]} [distractors] - Optional array of incorrect answer texts.
 * @property {string} [id] - Optional unique identifier for the question within its sheet.
 * @property {string} [sheetId] - The ID of the sheet this question belongs to.
 */

/**
 * @typedef {object} Sheet
 * @property {string} id - Unique identifier for the sheet.
 * @property {string} name - Display name of the sheet.
 * @property {boolean} isCustom - Whether the sheet is user-created.
 * @property {Question[]} questions - Array of questions in the sheet.
 */

/**
 * @typedef {object} HostQuestionsData
 * @property {Sheet[]} sheets - An array of sheet objects containing their questions.
 */

/**
 * @typedef {object} HostGameData
 * @property {HostQuestionsData} questionsData - The structured question data.
 * @property {string} difficulty - The difficulty level ('easy', 'medium', 'hard').
 */

// Define difficulty durations here or import from constants
const MAX_DISTRACTORS = 3; // Example constant

/**
 * Provides quiz data management and answer checking capabilities.
 * Can be instantiated to hold specific question sets.
 */
class QuizEngine {
    /**
     * Creates a new QuizEngine instance.
     */
    constructor() {
        // console.log("[QuizEngine] Instance created."); // Keep logging minimal for instances
        /** @type {Question[]} */
        this.questions = []; // Array of all loaded questions for this instance
        this.settings = null; // Store settings used for loading
        this.correctAnswerCount = 0; // Track correct answers internally for results
    }

    /**
     * [Factory Method] Creates and initializes a QuizEngine instance directly
     * from the data structure provided by the host.
     * @param {HostGameData} hostGameData - The data containing questionsData and difficulty.
     * @returns {QuizEngine} A new, populated QuizEngine instance.
     * @throws {Error} If hostGameData is invalid or contains no questions.
     */
    static createInstance(hostGameData) {
        if (!hostGameData || !hostGameData.questionsData || !hostGameData.difficulty) {
            throw new Error("Invalid host data provided to create QuizEngine instance.");
        }
        const newEngine = new QuizEngine();
        newEngine._loadDataFromHost(hostGameData); // Use internal method to load
        console.log(`[QuizEngine] Created instance from host data. ${newEngine.getQuestionCount()} questions loaded.`);
        return newEngine;
    }
    
    /**
     * [Singleton Access - Legacy Support] Gets the shared singleton instance.
     * NOTE: Prefer creating instances for isolated game modes (like MP client).
     * @returns {QuizEngine} The singleton instance.
     */
    static getInstance() {
        if (!QuizEngine._instance) {
            QuizEngine._instance = new QuizEngine();
            console.log("[QuizEngine] Singleton instance created.");
        }
        return QuizEngine._instance;
    }

    /**
     * [Internal] Loads question data from the host-provided structure.
     * @param {HostGameData} hostGameData
     * @private
     */
    _loadDataFromHost(hostGameData) {
        this.settings = { difficulty: hostGameData.difficulty }; // Store difficulty
        this.questions = [];
        this.correctAnswerCount = 0;

        if (!hostGameData.questionsData.sheets || hostGameData.questionsData.sheets.length === 0) {
             throw new Error("Host questions data contains no sheets.");
        }

        let allLoadedQuestions = [];
        for (const sheet of hostGameData.questionsData.sheets) {
            if (sheet.questions && sheet.questions.length > 0) {
                 // Assume questions have { question, answer }, add sheetId for context
                const processedQuestions = sheet.questions.map(q => ({ ...q, sheetId: sheet.id }));
                allLoadedQuestions = allLoadedQuestions.concat(processedQuestions);
            }
        }

        if (allLoadedQuestions.length === 0) {
             throw new Error("No valid questions found in host data sheets.");
        }
        
        // Shuffle the combined list
        this.questions = arrayUtils.shuffleArray(allLoadedQuestions);
    }

    /**
     * [For Singleton/Host Use] Loads and shuffles questions using QuestionsManager.
     * @param {string[]} sheetIds - Array of sheet IDs to load questions from.
     * @param {string} [difficulty='medium'] - Difficulty level.
     * @returns {Promise<void>}
     * @throws {Error} If no questions could be loaded.
     */
    async loadQuestionsFromManager(sheetIds, difficulty = 'medium') {
        // This method is primarily for the singleton instance or host
        console.log(`[QuizEngine Instance] Loading questions via Manager for sheets: ${sheetIds.join(', ')}`);
        this.settings = { sheetIds, difficulty };
        this.questions = [];
        this.correctAnswerCount = 0;

        eventBus.emit(Events.System.LoadingStart, { message: getTextTemplate('qeLoading') });
        try {
            let allLoadedQuestions = [];
            for (const sheetId of sheetIds) {
                try {
                    const sheetQuestions = await questionsManager.getQuestionsForSheet(sheetId);
                    if (sheetQuestions && sheetQuestions.length > 0) {
                        const processedQuestions = sheetQuestions.map(q => ({ ...q, sheetId: q.sheetId || sheetId }));
                        allLoadedQuestions = allLoadedQuestions.concat(processedQuestions);
                        console.log(`[QuizEngine Instance] Loaded ${sheetQuestions.length} questions from ${sheetId}`);
                    } else {
                        console.warn(`[QuizEngine Instance] No questions found or loaded for sheet: ${sheetId}`);
                    }
                } catch (error) {
                    console.error(`[QuizEngine Instance] Error processing questions from sheet ${sheetId}:`, error);
                    throw error;
                }
            }

            if (allLoadedQuestions.length === 0) {
                throw new Error(getTextTemplate('qeLoadError'));
            }

            this.questions = arrayUtils.shuffleArray(allLoadedQuestions);
            console.log(`[QuizEngine Instance] Total ${this.questions.length} questions loaded and shuffled.`);

        } finally {
            eventBus.emit(Events.System.LoadingEnd);
        }
    }

    // --- Core Quiz Methods (Operate on this.questions) ---

    /** Returns the total number of questions loaded. */
    getQuestionCount() {
        return this.questions.length;
    }

    /** Retrieves question data by index. */
    getQuestionData(index) {
        if (index < 0 || index >= this.questions.length) {
            return null;
        }
        return { ...this.questions[index] }; // Return shallow copy
    }

    /** Gets the correct answer text by index. */
    getCorrectAnswer(index) {
        const question = this.getQuestionData(index);
        return question ? question.answer : null;
    }

    /** Generates and shuffles answers (correct + distractors) by index. */
    getShuffledAnswers(index) {
        const currentQuestion = this.getQuestionData(index);
        if (!currentQuestion) return [];

        const correctAnswer = currentQuestion.answer;
        let allAnswers = [correctAnswer];

        if (Array.isArray(currentQuestion.distractors) && currentQuestion.distractors.length > 0) {
            allAnswers = allAnswers.concat(currentQuestion.distractors);
        } else {
            // Generate simple distractors from other answers in this instance's pool
            const otherAnswers = this.questions
                .map(q => q.answer)
                .filter((ans, idx) => typeof ans === 'string' && ans.trim().toLowerCase() !== correctAnswer.trim().toLowerCase() && idx !== index)
                .filter((ans, pos, self) => self.findIndex(a => a.trim().toLowerCase() === ans.trim().toLowerCase()) === pos) // Unique distractors
                .slice(0, MAX_DISTRACTORS);

             if (otherAnswers.length > 0) {
                  allAnswers = allAnswers.concat(otherAnswers);
             } else {
                   console.warn(`[QuizEngine Instance] Could not generate distractors for question ${index}.`);
             }
        }
        return arrayUtils.shuffleArray(allAnswers);
    }

    /** Checks a submitted answer, performs comparison, updates internal count. */
    checkAnswer(index, submittedAnswer) {
        const question = this.getQuestionData(index);
        if (!question) {
            return { isCorrect: false, correctAnswer: null };
        }
        const correctAnswer = question.answer;
        let isCorrect = false;
        if (typeof submittedAnswer === 'string' && typeof correctAnswer === 'string') {
            isCorrect = submittedAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
        }
        if (isCorrect) {
             this.correctAnswerCount++;
        }
        return { isCorrect: isCorrect, correctAnswer: correctAnswer };
    }

    /** Checks if the quiz is complete based on the next index. */
     isQuizComplete(nextIndex) {
         return nextIndex >= this.questions.length;
     }

     /** Gets the count of correctly answered questions. */
      getCorrectCount() {
          return this.correctAnswerCount;
      }

      // --- Private helper for distractor generation (if needed, currently inline) ---
      // _generateDistractors(...)
}

// Initialize the singleton instance variable for legacy access method
QuizEngine._instance = null;

// Export the class itself, allowing instantiation
export default QuizEngine; import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';
import Views from '../core/view-constants.js'; // Import Views constants
import ErrorDialog from '../dialogs/error-dialog.js'; // Assuming ErrorDialog export
// Import the default export object from miscUtils
import miscUtils from '../utils/miscUtils.js'; 
// <<< ADD Import for ConnectionStatus >>>
import { ConnectionStatus } from '../core/connection-constants.js';

// Import game mode classes
import SinglePlayerGame from '../game/SinglePlayerGame.js'; // Corrected path case
import MultiplayerGame from '../game/MultiplayerGame.js'; // Corrected path case
import PracticeGame from '../game/PracticeGame.js';     // Corrected path case

// Import services
import questionsManager from './QuestionsManager.js'; // Import QuestionsManager
import webRTCManager from './WebRTCManager.js';      // Assuming singleton
import uiManager from '../ui/UIManager.js';          // Import UIManager to access components
import NamePromptDialog from '../dialogs/name-prompt-dialog.js'; // Import for type check
import WaitingDialog from '../dialogs/waiting-dialog.js'; // Import WaitingDialog

import MultiplayerHostManager from './MultiplayerHostManager.js';
import MultiplayerClientManager from './MultiplayerClientManager.js';
// Import MultiplayerLobbyDialog for type hints or direct showing if needed
import MultiplayerLobbyDialog from '../dialogs/multiplayer-lobby-dialog.js'; 
import { MSG_TYPE } from '../core/message-types.js'; // NEW Import from isolated file
import QuizEngine from '../services/QuizEngine.js'; // Import class
import highscoreManager from './HighscoreManager.js'; // Import the singleton instance

/**
 * Coordinates the creation and management of different game modes.
 * Supports ASYNCHRONOUS multiplayer flow.
 */
class GameCoordinator {
    /**
     * Initializes the GameCoordinator.
     * @param {QuestionsManager} questionsManagerInstance - An instance of the QuestionsManager.
     * @param {MultiplayerClientManager} multiplayerClientManagerInstance - An instance of MultiplayerClientManager.
     */
    constructor(questionsManagerInstance, multiplayerClientManagerInstance) {
        console.info("[GameCoordinator ASYNC] Initializing...");

        // Assign injected dependencies
        this.questionsManager = questionsManagerInstance || questionsManager; // Use singleton as fallback
        this.multiplayerClientManager = multiplayerClientManagerInstance;
        this.webRTCManager = webRTCManager; // Store the singleton instance

        if (!this.questionsManager) {
             console.error("[GameCoordinator] FATAL: QuestionsManager instance is missing!");
             // Handle critical error - maybe show an error message and halt?
        }
        if (!this.multiplayerClientManager) {
             console.warn("[GameCoordinator] MultiplayerClientManager instance not provided. Client functionality might be limited.");
             // This might be acceptable if only single-player is used, but warn anyway.
        }

        this.activeGame = null; // Reference to the currently active game instance
        this.activeHostManager = null; // Reference to the active MultiplayerHostManager
        this.pendingHostInfo = null; // Store temporary info while host lobby is active
        this.pendingJoinInfo = null; // Store temporary info while join process is active
        this.currentGameMode = null; // 'single', 'practice', 'multiplayer-host', 'multiplayer-client'

        this.localPlayerName = null; // Stores the name of the local player (for client)
        this.currentPlayerList = new Map(); // Store the current player list (client-side)

        // Load player name early
        this._loadPlayerName();

        // Bind methods BEFORE registering listeners
        this._bindMethods(); 
        // Register listeners AFTER binding
        this.registerListeners(); 
    }

    /**
     * Binds methods used as event handlers to the correct `this` context.
     * @private
     */
    _bindMethods() {
        // Bind all methods used as event handlers
        this.handleRequestSinglePlayer = this.handleRequestSinglePlayer.bind(this);
        this.handleRequestPractice = this.handleRequestPractice.bind(this);
        this.handleRequestMultiplayerChoice = this.handleRequestMultiplayerChoice.bind(this);
        this.handleStartRequested = this.handleStartRequested.bind(this);
        this.handleStartMultiplayerHost = this.handleStartMultiplayerHost.bind(this);
        this.handleShowJoinLobby = this.handleShowJoinLobby.bind(this);
        this.handleJoinMultiplayerAttempt = this.handleJoinMultiplayerAttempt.bind(this);
        this.handleHostStartGame = this.handleHostStartGame.bind(this);
        this.handleClientConfirmJoin = this.handleClientConfirmJoin.bind(this);
        this.handleLobbyCancel = this.handleLobbyCancel.bind(this); // Bind the cancel handler
        this.handleLeaveGame = this.handleLeaveGame.bind(this);
        this.handleWebRTCConnectionFailure = this.handleWebRTCConnectionFailure.bind(this);
        this.handleClientReceivedGameInfo = this.handleClientReceivedGameInfo.bind(this);
        this._handleValidJoinCodeDetected = this._handleValidJoinCodeDetected.bind(this);
        this._handleClientConnectedToHost = this._handleClientConnectedToHost.bind(this);
        this._handlePlayerListUpdate = this._handlePlayerListUpdate.bind(this);
        this._handleWebRTCMessageReceived = this._handleWebRTCMessageReceived.bind(this); // ADD: Bind the new handler
        // ADD: Bind handler for local player finishing
        this._handleLocalPlayerFinished = this._handleLocalPlayerFinished.bind(this); 
        // ADD: Bind handler for saving score
        this.handleSaveHighscore = this.handleSaveHighscore.bind(this);
        // +++ ADD: Bind handler for Host Waiting +++
        this._handleHostWaiting = this._handleHostWaiting.bind(this);
        this._handleMultiplayerDialogClosed = this._handleMultiplayerDialogClosed.bind(this); // Bind new handler
    }

    /**
     * Registers listeners for UI events that trigger game starts.
     * Uses pre-bound methods from _bindMethods.
     * @private
     */
    registerListeners() {
        console.info("[GameCoordinator ASYNC] Registering event listeners...");
        // Listen for UI events signaling intent - Use pre-bound methods
        eventBus.on(Events.UI.MainMenu.StartSinglePlayerClicked, this.handleRequestSinglePlayer);
        eventBus.on(Events.UI.MainMenu.StartPracticeClicked, this.handleRequestPractice);
        eventBus.on(Events.UI.MainMenu.JoinMultiplayerClicked, this.handleRequestMultiplayerChoice);

        // Listen for generic StartRequested event (likely from SheetSelection or future direct starts)
        eventBus.on(Events.Game.StartRequested, this.handleStartRequested); 

        // Multiplayer specific UI flows
        eventBus.on(Events.UI.MultiplayerChoice.HostClicked, this.handleStartMultiplayerHost);
        eventBus.on(Events.UI.MultiplayerChoice.JoinClicked, this.handleShowJoinLobby); 
        eventBus.on(Events.UI.JoinLobby.SubmitCodeClicked, this.handleJoinMultiplayerAttempt);
        eventBus.on(Events.UI.HostLobby.StartGameClicked, this.handleHostStartGame);
        eventBus.on(Events.UI.JoinLobby.ConfirmClicked, this.handleClientConfirmJoin);
        eventBus.on(Events.UI.HostLobby.CancelClicked, this.handleLobbyCancel); // Add listener
        eventBus.on(Events.UI.JoinLobby.CancelClicked, this.handleLobbyCancel); // Add listener (uses same handler)
        eventBus.on(Events.UI.MultiplayerLobby.LeaveClicked, this.handleLobbyCancel); // ADDED: Treat leaving lobby same as cancelling

        // Listen for game lifecycle events to clean up
        eventBus.on(Events.Game.Finished, (payload) => this.handleGameFinished(payload));
        eventBus.on(Events.UI.GameArea.LeaveGameClicked, this.handleLeaveGame);
        eventBus.on(Events.Multiplayer.Client.DisconnectedFromHost, this.handleLeaveGame); 
        eventBus.on(Events.WebRTC.ConnectionFailed, this.handleWebRTCConnectionFailure);

        // Listen for game info received by client to store settings
        eventBus.on(Events.Multiplayer.Client.GameInfoReceived, this.handleClientReceivedGameInfo);

        // Listen for join code detected in URL
        eventBus.on(Events.System.ValidJoinCodeDetected, this._handleValidJoinCodeDetected);

        // Listen for connection events from WebRTCManager
        eventBus.on(Events.Multiplayer.Client.ConnectedToHost, this._handleClientConnectedToHost);

        // --- ADD: Listener for raw WebRTC messages (for GAME_INFO etc.) ---
        eventBus.on(Events.WebRTC.MessageReceived, this._handleWebRTCMessageReceived);

        // --- ADD: Listener for player list updates (host side) ---
        eventBus.on(Events.Multiplayer.Common.PlayerListUpdated, this._handlePlayerListUpdate.bind(this));

        // ADD: Listen for the local client finishing their game
        eventBus.on(Events.Game.LocalPlayerFinished, this._handleLocalPlayerFinished);

        // +++ ADDED: Listen for Host Waiting event +++
        eventBus.on(Events.Multiplayer.HostWaiting, this._handleHostWaiting);
        
        // +++ ADDED: Listen for Save Score click +++
        eventBus.on(Events.UI.EndDialog.SaveScoreClicked, this.handleSaveHighscore);

        // +++ ADDED: Listen for Multiplayer End Dialog Closed event +++
        eventBus.on(Events.UI.MultiplayerEndDialog.Closed, this._handleMultiplayerDialogClosed);

        // <<< Add Listener for Play Again Click >>>
        eventBus.on(Events.UI.MultiplayerEndDialog.PlayAgainClicked, this._handlePlayAgainRequest);

        console.info("[GameCoordinator ASYNC] Event listeners registered.");
    }

    /**
     * Handles the request to start a single-player game from the Main Menu.
     * Navigates to the SheetSelection view.
     * @private
     */
    handleRequestSinglePlayer() {
        console.log("[GameCoordinator] Received StartSinglePlayerClicked from MainMenu. Navigating to Sheet Selection.");
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot navigate to sheet selection, a game is active.");
            // Use template for feedback
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }
        // Navigate to Sheet Selection, passing the intended mode
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.SheetSelection, data: { mode: 'single' } });
    }
    
    /**
     * Handles the request to start a practice game from the Main Menu.
     * Navigates to the SheetSelection view.
     * @private
     */
    handleRequestPractice() {
        console.log("[GameCoordinator] Received StartPracticeClicked from MainMenu. Navigating to Sheet Selection.");
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot navigate to sheet selection, a game is active.");
            // Use template for feedback
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }
        // Navigate to Sheet Selection, passing the intended mode
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.SheetSelection, data: { mode: 'practice' } });
    }

    /**
     * Handles the generic request to start a game, typically from SheetSelectionComponent.
     * @param {object} payload - Event payload from Events.Game.StartRequested
     * @param {'single' | 'practice' | 'multiplayer-host' | 'multiplayer-join'} payload.mode - The requested game mode.
     * @param {object} payload.settings - Game settings (e.g., sheetIds, difficulty).
     * @param {string} [payload.playerName] - Player's name (may be needed for some modes).
     * @param {string} [payload.hostId] - Host ID if joining.
     * @private
     */
    async handleStartRequested({ mode, settings, playerName, hostId }) {
        console.log(`[GameCoordinator ASYNC] Received Game.StartRequested. Mode: ${mode}`, { settings, playerName, hostId });
        if (this.activeGame || this.activeHostManager) { // Check both active game and host manager
            console.warn("[GameCoordinator ASYNC] Cannot start new game/host, another session is active.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameErrorStartWhileActive'), level: 'error' }); 
            return;
        }

        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.Loading });
        await new Promise(resolve => setTimeout(resolve, 100)); 

        try {
            let quizEngineInstance;
            switch (mode) {
                case 'single':
                    console.log(`[GameCoordinator ASYNC] Starting Single Player game with settings:`, settings);
                    // Get the SINGLETON engine instance
                    quizEngineInstance = QuizEngine.getInstance();
                    // Load questions into the SINGLETON instance
                    await quizEngineInstance.loadQuestionsFromManager(settings.sheetIds, settings.difficulty);
                    if (quizEngineInstance.getQuestionCount() === 0) {
                         throw new Error("No questions loaded for selected sheets/difficulty.");
                    }
                    
                    const spPlayerName = playerName || miscUtils.getTextTemplate('defaultPlayerName'); 
                    // Create game instance, passing the SINGLETON engine
                    this.activeGame = new SinglePlayerGame(settings, quizEngineInstance, spPlayerName);
                    // BaseGameMode start() will now use the passed (and loaded) instance
                    await this.activeGame.start(); 
                    break;
                case 'practice':
                    console.log(`[GameCoordinator ASYNC] Starting Practice game with settings:`, settings);
                     // Get the SINGLETON engine instance
                     quizEngineInstance = QuizEngine.getInstance();
                     // Load questions into the SINGLETON instance
                     await quizEngineInstance.loadQuestionsFromManager(settings.sheetIds, settings.difficulty);
                     if (quizEngineInstance.getQuestionCount() === 0) {
                          throw new Error("No questions loaded for selected sheets/difficulty.");
                     }
                    // Create game instance, passing the SINGLETON engine
                    this.activeGame = new PracticeGame(settings, quizEngineInstance); // Assuming PracticeGame constructor is similar
                    await this.activeGame.start(); 
                    break;
                case 'multiplayer-host':
                    // ... (existing multiplayer-host logic remains largely the same) ...
                    // It fetches questionsData, starts WebRTCManager, then creates MultiplayerHostManager
                    // MultiplayerHostManager internally uses QuizEngine.getInstance() for its logic
                    // And MultiplayerGame (Host) constructor also gets the singleton instance passed.
                    // So, no QuizEngine instance needs explicit handling here for the *host* flow.
                    console.log(`[GameCoordinator ASYNC] Handling StartRequested for multiplayer-host. Player: ${playerName}, Settings:`, settings);
                    // ... (rest of host logic: validation, fetch questions, start WebRTC, create Host Manager) ...
                     // Fetch the full question data for the selected sheets
                    let hostQuestionsData = null;
                    try {
                         // ... fetch logic using this.questionsManager ...
                          if (!settings || !Array.isArray(settings.sheetIds) || settings.sheetIds.length === 0) {
                               throw new Error("No sheet IDs selected.");
                          } 
                          console.log(`[GameCoordinator ASYNC] Fetching questions for sheets:`, settings.sheetIds);
                          hostQuestionsData = await this.questionsManager.getQuestionsForSheets(settings.sheetIds);
                          console.log(`[GameCoordinator ASYNC] Fetched questions data:`, hostQuestionsData);
                         
                    } catch (fetchError) { /* ... error handling ... */ return; }

                    if (!hostQuestionsData || !hostQuestionsData.sheets || hostQuestionsData.sheets.length === 0) { /* ... error handling ... */ return; }
                    
                    console.log(`[GameCoordinator ASYNC] Starting WebRTC host for ${playerName}...`);
                    try {
                         // Pass fetched questionsData and difficulty to WebRTCManager
                         await webRTCManager.startHost(playerName, hostQuestionsData, settings.difficulty); 
                    } catch (rtcError) { /* ... error handling ... */ return; }
                    
                    const hostId = webRTCManager.getMyPeerId();
                    if (!hostId) { /* ... error handling ... */ return; }
                    
                    // ---- Store Complete Settings in pendingHostInfo ----
                    this.pendingHostInfo = { 
                        playerName: playerName, 
                        settings: settings // Now includes sheetIds from the event
                    };
                    console.log(`[GameCoordinator ASYNC] Stored complete pending host info:`, this.pendingHostInfo);
                    // ---- End Store ----

                    // Create and initialize MultiplayerHostManager (it uses singleton QuizEngine internally)
                    try {
                        console.log(`[GameCoordinator ASYNC] Creating MultiplayerHostManager for host ${hostId} with name ${playerName}`);
                        // Host Manager doesn't need the QuizEngine instance passed, uses singleton
                        const hostManager = new MultiplayerHostManager(playerName, settings.sheetIds, settings.difficulty, hostId);
                        console.log("[GameCoordinator ASYNC] Initializing MultiplayerHostManager...");
                        await hostManager.initialize(); // Loads questions into singleton engine
                        console.log("[GameCoordinator ASYNC] Starting hosting listeners in MultiplayerHostManager...");
                        hostManager.startHosting();
                        this.activeHostManager = hostManager;
                        this.currentGameMode = 'multiplayer-host';
                    } catch (hostManagerError) { /* ... error handling ... */ return; }

                    console.log("[GameCoordinator ASYNC] Navigating to Host Lobby.");
                    eventBus.emit(Events.Navigation.ShowView, { viewName: Views.HostLobby });
                    break;
                case 'multiplayer-join':
                     console.error("[GameCoordinator ASYNC] Internal Error: Attempted to join multiplayer via unsupported StartRequested event. Use MultiplayerChoice -> JoinClicked flow.");
                     // Log detailed error, show generic feedback
                     eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
                     eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
                    break;
                default:
                    // Log detailed error, show generic feedback
                    console.error(`[GameCoordinator ASYNC] Internal Error: Unknown game mode requested: ${mode}`);
                    eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
                    eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
                    return; // Exit early
            }
            console.log(`[GameCoordinator ASYNC] ${mode} game instance created and started or host manager initialized.`);
        } catch (error) {
            // ... (existing error handling remains the same) ...
            console.error(`[GameCoordinator ASYNC] Error during game start process for mode \'${mode}\':`, error);
            eventBus.emit(Events.System.ShowFeedback, { message: error.message || miscUtils.getTextTemplate('gameErrorGenericStartFail'), level: 'error' });
            this.resetCoordinatorState(); // Use central reset function
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu }); // Fallback to main menu
        }
    }

    /**
     * Handles the request to navigate to the Multiplayer Choice screen.
     * @private
     */
     handleRequestMultiplayerChoice() {
        console.log("[GameCoordinator] Received JoinMultiplayerClicked from MainMenu. Navigating to MP Choice.");
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot navigate to MP choice, a game is active.");
             // Use template for feedback
             eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }
        // Navigate directly to Multiplayer Choice
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MultiplayerChoice });
     }

    /**
     * Handles the Host button click from the Multiplayer Choice view.
     * Stores initial host info and navigates to Sheet Selection.
     * @param {object} payload - From Events.UI.MultiplayerChoice.HostClicked.
     * @param {string} payload.playerName - The host's chosen name.
     * @param {object} payload.settings - Initial settings (likely just difficulty).
     * @private
     */
    handleStartMultiplayerHost({ playerName, settings }) {
        console.log(`[GameCoordinator] Received HostClicked from MultiplayerChoice. Player: ${playerName}`, settings);
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot navigate to host sheet selection, a game is active.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }

        if (!playerName) {
            console.error("[GameCoordinator] HostClicked event missing player name.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
            return;
        }

        // Store initial info (playerName and difficulty)
        // sheetIds will be added later by SheetSelectionComponent
        this.pendingHostInfo = { 
            playerName: playerName, 
            settings: settings || { difficulty: 'medium' } // Ensure settings object exists
        }; 
        console.log("[GameCoordinator] Stored pending host info:", this.pendingHostInfo);

        // Navigate to Sheet Selection, passing the mode and player name
        eventBus.emit(Events.Navigation.ShowView, { 
            viewName: Views.SheetSelection, 
            data: { 
                mode: 'multiplayer-host',
                playerName: playerName, // Pass name so SheetSelection knows who is hosting
                difficulty: settings.difficulty 
            } 
        });
    }

    /**
     * Handles the Join button click from the Multiplayer Choice view.
     * Navigates the user to the Join Lobby view.
     * @param {object} payload - From Events.UI.MultiplayerChoice.JoinClicked.
     * @param {string} payload.playerName - The player's chosen name.
     * @private
     */
    handleShowJoinLobby({ playerName }) {
        console.log(`[GameCoordinator] Received JoinClicked from MultiplayerChoice. Player: ${playerName}. Navigating to Join Lobby.`);
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot navigate to join lobby, a game is active.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }

        if (!playerName) {
            console.error("[GameCoordinator] JoinClicked event missing player name.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
            return;
        }

        // Navigate to Join Lobby, passing the player name
        eventBus.emit(Events.Navigation.ShowView, { 
            viewName: Views.JoinLobby, 
            data: { 
                playerName: playerName 
            } 
        });
    }

    /**
     * Handles the detection of a valid join code in the URL parameters.
     * Retrieves player name, navigates to Join Lobby (connecting state),
     * and triggers the connection attempt.
     * @param {object} payload - From Events.System.ValidJoinCodeDetected.
     * @param {string} payload.code - The valid 6-digit join code.
     * @private
     */
    _handleValidJoinCodeDetected({ joinCode }) {
        console.log('[DEBUG] Raw arguments received in _handleValidJoinCodeDetected:', arguments); // Added for debugging
        console.log(`[GameCoordinator] Received ValidJoinCodeDetected event. Code: ${joinCode}`);
        // Ensure player name is loaded/generated first
        if (!this.localPlayerName) {
            this._loadPlayerName();
        }
        // Use the CORRECT function name via miscUtils default import
        const playerName = this.localPlayerName || miscUtils.generateRandomPlayerName(); 
        
        // Show Join Lobby with connecting state
        eventBus.emit(Events.Navigation.ShowView, {
            viewName: Views.JoinLobby,
            data: { playerName: playerName, joinCode: joinCode, showConnecting: true }
        });
        // Automatically trigger the connection attempt
        this.handleJoinMultiplayerAttempt({ code: joinCode, playerName: playerName });
    }

    /**
     * Handles the *initial attempt* to join via code submission (manual or from URL).
     * Triggers WebRTC connection attempt.
     * @param {object} payload - From Events.UI.JoinLobby.SubmitCodeClicked.
     * @param {string} payload.code - Submitted host code.
     * @param {string} payload.playerName - Joining player's name.
     * @private
     */
    async handleJoinMultiplayerAttempt({ code, playerName }) {
        console.log(`[GameCoordinator] Received Join SubmitCodeClicked event. Code: ${code}, Player: ${playerName}`);
        if (this.activeGame) {
            console.warn("[GameCoordinator] Cannot join, a game/connection is active.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameErrorJoinWhileActive'), level: 'error' });
            return;
        }
        if (!code || code.length !== 6 || !playerName) {
            console.error("[GameCoordinator] Invalid join attempt data.", { code, playerName });
            eventBus.emit(Events.UI.JoinLobby.Error, { message: miscUtils.getTextTemplate('joinErrorInvalidInput') });
            return;
        }

        // Store the local player name AND initialize pending join info
        this.localPlayerName = playerName;
        this.pendingJoinInfo = { 
            hostId: code, // Store the target host ID
            playerName: playerName, // Store the name used for this attempt
            questionsData: null, // Will be populated by GameInfoReceived
            difficulty: null,    // Will be populated by GameInfoReceived
            players: null        // Will be populated by GameInfoReceived
        };
        console.log(`[GameCoordinator] Initialized pendingJoinInfo for host ${code}`);

        console.log(`[GameCoordinator] Attempting WebRTC client connection to host: ${code}`);
        // Start connection attempt (WebRTCManager will handle the UI updates via events)
        this.webRTCManager.connectToHost(code, playerName);
    }

     /**
     * Handles the host clicking "Start Game" in the Host Lobby.
     * Creates and starts the MultiplayerGame instance (host side).
     * @private
     */
    async handleHostStartGame() {
        console.log("[GameCoordinator] Received StartGameClicked from HostLobby.");
        if (this.activeGame) {
            console.warn("[GameCoordinator] Host StartGameClicked ignored, a game is already active.");
             // Use template for feedback
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('gameWarnAlreadyActive'), level: 'warn' });
            return;
        }

        if (!this.pendingHostInfo || !this.pendingHostInfo.playerName || !this.pendingHostInfo.settings || !this.pendingHostInfo.settings.sheetIds) {
            console.error("[GameCoordinator] Internal Error: Host clicked Start Game, but pendingHostInfo is missing or incomplete (needs sheetIds!).", this.pendingHostInfo);
            // Use template for feedback
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu }); // Go back home
            this.pendingHostInfo = null; // Clear partial info
            return;
        }

        // Get the peer ID early to avoid redeclaration
        const myPeerId = webRTCManager.getMyPeerId();
        
        // Check if any clients are connected
        const players = webRTCManager.getConnectedPlayers();
        let totalClientCount = 0;
        
        if (players && players.size > 0) {
            players.forEach((playerData, peerId) => {
                // Skip the host in the count
                if (peerId !== myPeerId) {
                    totalClientCount++;
                }
            });
        }
        
        // Ensure there's at least one client connected
        if (totalClientCount === 0) {
            console.warn("[GameCoordinator] Host tried to start game without any connected clients.");
            eventBus.emit(Events.System.ShowFeedback, { 
                message: miscUtils.getTextTemplate('mpHostErrorNoClients') || "Cannot start game without players", 
                level: 'error'
            });
            return;
        }

        // Retrieve stored info
        const { playerName, settings } = this.pendingHostInfo;

        if (!myPeerId) {
            console.error("[GameCoordinator] Internal Error: Host clicked Start Game, but WebRTCManager has no local peer ID.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('mpHostErrorNoIdOnStart'), level: 'error' }); 
            // Potentially try to re-init or guide user?
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            this.pendingHostInfo = null; // Clear pending info
            return;
        }

        console.log(`[GameCoordinator] Starting Multiplayer Game as Host. Player: ${playerName}, HostID: ${myPeerId}, Settings:`, settings);
        this.pendingHostInfo = null; // Clear pending info now that we're starting the game

        // --- Ensure HostManager exists and tell it to start the game sequence --- 
        if (!this.activeHostManager) {
            console.error("[GameCoordinator] Critical Error: handleHostStartGame called without an active HostManager.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            return; // Stop execution
        }
        
        // Tell the manager to stop lobby listeners and broadcast GAME_START
        if (typeof this.activeHostManager.initiateGameStart === 'function') {
             this.activeHostManager.initiateGameStart();
         } else {
             console.error("[GameCoordinator] Error: activeHostManager missing initiateGameStart method!");
             eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
             eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
             return; // Stop execution
         }
        // --- End HostManager Start --- 

        // Show loading screen WHILE the game instance is created/started
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.Loading });
        await new Promise(resolve => setTimeout(resolve, 100)); // Allow loading screen to render

        try {
             // Game Instance Creation (Host)
            // This should happen AFTER HostManager has broadcasted GAME_START
            console.log("[GameCoordinator] Creating host MultiplayerGame instance...");
            this.activeGame = new MultiplayerGame(
                true,                 // isHost
                playerName,
                settings,             // Host expects settings
                settings.difficulty,
                myPeerId,
                webRTCManager
            );
            await this.activeGame.start(); // This emits Game.Started -> Navigates UI
            this.currentGameMode = 'multiplayer-host'; // Set mode tracking AFTER successful start

        } catch (error) {
            console.error("[GameCoordinator] Error starting Multiplayer Game (Host):", error);
            // Use template for feedback
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' }); 
            this.activeGame = null; // Nullify on error
            webRTCManager.closeConnection(); // Attempt to clean up WebRTC
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu }); // Back to menu
        }
    }

    /**
     * Handles receiving game info from the host (forwarded by MultiplayerClientManager).
     * Stores the info if the host ID matches the pending join attempt.
     * @param {object} payload - From Events.Multiplayer.Client.GameInfoReceived.
     * @param {object} payload.questionsData - The full question data.
     * @param {string} payload.difficulty - Game difficulty.
     * @param {Map<string, object>} payload.players - Current player list.
     * @param {string} payload.hostId - Host's PeerJS ID.
     * @private
     */
    handleClientReceivedGameInfo({ questionsData, difficulty, players, hostId }) {
        console.log(`[GameCoordinator] Client received Game Info from host ${hostId}`, { questionsData, difficulty, players });

        if (!this.pendingJoinInfo || this.pendingJoinInfo.hostId !== hostId) {
            console.warn("[GameCoordinator] Received GameInfo, but no matching pendingJoinInfo found or hostId mismatch.", 
                         { expectedHost: this.pendingJoinInfo?.hostId, receivedHost: hostId });
            // This might happen if the join process was cancelled or timed out just before info arrived.
            return;
        }

        // Store the received game details in the pending info
        this.pendingJoinInfo.questionsData = questionsData; 
        this.pendingJoinInfo.difficulty = difficulty;
        this.pendingJoinInfo.players = players; // Store players map as well
        console.log("[GameCoordinator] Stored game details in pendingJoinInfo.");
        
        // JoinLobbyComponent also listens for GameInfoReceived directly to display info.
    }

    /**
     * Handles the client confirming they want to join after seeing game info.
     * Sent by JoinLobbyComponent when the confirm button is clicked.
     * Triggers the sending of the c_requestJoin message to the host.
     * @param {object} payload - Event payload from Events.UI.JoinLobby.ConfirmClicked.
     * @param {string} payload.playerName - The name the player confirmed with.
     * @private
     */
    handleClientConfirmJoin({ playerName }) {
        if (!this.pendingJoinInfo || !this.pendingJoinInfo.hostId) {
            console.error("[GameCoordinator] handleClientConfirmJoin called, but no pending join info or hostId found.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('genericInternalError'), level: 'error' });
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            return;
        }

        const hostId = this.pendingJoinInfo.hostId;
        console.log(`[GameCoordinator] Client confirmed join. Host ID: ${hostId}, Player Name: ${playerName}`);

        // Update the stored player name for this join attempt
        this.pendingJoinInfo.playerName = playerName;

        // Tell WebRTCManager (via Client Manager) to send the join request
        try {
            if (!this.multiplayerClientManager) {
                throw new Error("MultiplayerClientManager is not available.");
            }
            console.log(`[GameCoordinator] Sending c_requestJoin message to host ${hostId}`);
            this.multiplayerClientManager.sendJoinRequest(playerName);
        } catch (error) {
            console.error("[GameCoordinator] Error sending join request:", error);
            eventBus.emit(Events.System.ShowFeedback, { message: `Error joining game: ${error.message || 'Network issue'}`, level: 'error' });
            // Don't necessarily navigate away, let user retry?
            // Maybe reset state partially?
            this.resetCoordinatorState(); // For now, reset fully and go to main menu
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            return;
        }

        // Successfully sent join request. Now show the lobby/waiting dialog.
        console.log("[GameCoordinator] Join request sent. Showing Multiplayer Lobby Dialog.");
        eventBus.emit(Events.Navigation.ShowView, { 
            viewName: Views.MultiplayerLobby, // Use constant
            data: { 
                // Pass any initial data needed by the lobby dialog?
                // e.g., maybe the player list received in GameInfo?
                players: this.pendingJoinInfo.lastReceivedGameInfo?.players, 
                localPlayerId: webRTCManager.peerId // Pass local ID for highlighting
            } 
        });
        
        // No longer need the JoinLobby component view active.
        // (It should have hidden itself already when emitting the event).
    }

    /**
     * Handles cancelling the host or join lobby process OR leaving the client waiting lobby.
     * Cleans up any pending state and navigates back to the main menu.
     * @private
     */
    handleLobbyCancel() {
        console.log("[GameCoordinator] Lobby cancelled or left.");
        const wasHost = this.pendingHostInfo !== null;
        const wasJoining = this.pendingJoinInfo !== null;

        // Reset pending states
        this.pendingHostInfo = null;
        this.pendingJoinInfo = null;

        // Close WebRTC connection if it was initiated
        if (wasHost || wasJoining) {
            webRTCManager.closeConnection(); // Close connection if host/client init started
        }

        // Ensure any active game instance is cleaned up (shouldn't be one, but safety)
        this.resetCoordinatorState();

        // Navigate back to the main menu
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
    }

    /**
     * Instantiates and starts a MultiplayerGame instance (either host or client).
     * @param {boolean} isHost - True if starting as host, false as client.
     * @param {string} playerName - Local player's name.
     * @param {object} gameData - Either settings (host) or questionsData (client).
     * @param {string} difficulty - Game difficulty (used by both).
     * @param {string} peerId - Own ID if host, Host's ID if client.
     * @private
     */
    async startMultiplayerGameInstance(isHost, playerName, gameData, difficulty, peerId) {
        // REMOVED: Loading screen display. Client stays on JoinLobby waiting view.
        // eventBus.emit(Events.Navigation.ShowView, { viewName: Views.Loading });
        // await new Promise(resolve => setTimeout(resolve, 100)); 

        try {
             // Structure the gameData argument based on role
             let constructorGameData;
             if (isHost) {
                 // Host expects the settings object directly
                 constructorGameData = gameData; 
             } else {
                 // Client expects an object like { questionsData: ... }
                 // Ensure gameData passed here is the actual questions object
                 if (!gameData || !Array.isArray(gameData.sheets)) { 
                     console.error("[GameCoordinator] Invalid questions data provided for client instance:", gameData);
                     throw new Error("Internal error: Invalid questions data format for client.");
                 }
                 constructorGameData = { questionsData: gameData }; // Wrap it
             }

             // Pass difficulty to constructor for both host and client
             // Pass the correctly structured constructorGameData
             this.activeGame = new MultiplayerGame(isHost, playerName, constructorGameData, difficulty, peerId, webRTCManager);
             
             this.currentGameMode = isHost ? 'multiplayer-host' : 'multiplayer-client'; // Set mode tracking
             
             await this.activeGame.start();
            // Navigation to GameArea happens via Game.Started event
        } catch (error) {
            console.error(`[GameCoordinator] Error starting Multiplayer Game (${isHost ? 'Host' : 'Client'}):`, error);
             const errorMsg = isHost ? miscUtils.getTextTemplate('mpHostErrorGameStartFail') : miscUtils.getTextTemplate('mpClientErrorGameStartFail');
             eventBus.emit(Events.System.ShowFeedback, { message: errorMsg, level: 'error' }); 
            this.activeGame = null; // Nullify on error
            if (!isHost) { // Only close connection if client fails to start game instance
                 webRTCManager.closeConnection(); 
            }
            // Ensure navigation back to MainMenu on error, NOT loading
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu }); // Back to menu
        }
    }

    // --- Game Lifecycle Handlers --- 

    /**
     * Handles the end of any game mode.
     * Cleans up the active game instance.
     * NOTE: For multiplayer clients, final cleanup is deferred until GAME_OVER is received from host.
     * @private
     */
    handleGameFinished({ mode, results }) {
        console.log(`[GameCoordinator ASYNC] Received Game.Finished event for mode: ${mode}`, results);

        // --- Client Ignore Host's Local Finish ---
        if (this.currentGameMode === 'multiplayer-client' && mode === 'multiplayer-host') {
            console.log("[GameCoordinator Client] Ignored host's local Game.Finished event. Waiting for GAME_OVER message.");
            return; // Client waits for the GAME_OVER message via WebRTC
        }
        // --- End Ignore ---

        const wasMultiplayerClient = (mode === 'multiplayer-client');

        if (this.activeGame) {
            // If it's NOT the client finishing its local loop, clean up now.
            if (!wasMultiplayerClient) {
                 console.log(`[GameCoordinator ASYNC] Cleaning up active ${mode} game.`);

                 // Store results before potentially destroying the game object that holds them
                 // Use optional chaining for safety in case results are missing
                 const finalResults = results || this.activeGame?.getFinalResults?.();

                 if (typeof this.activeGame.destroy === 'function') {
                     this.activeGame.destroy();
                 }
                 this.activeGame = null;
                 this.currentGameMode = null;

                 // --- HIDE Waiting Dialog if open ---
                 /** @type {import('../dialogs/waiting-dialog').default | undefined} */
                 const waitingDialog = uiManager.getComponent('WaitingDialog');
                 if (waitingDialog && waitingDialog.isOpen) { // Check if it's actually open
                     console.log("[GameCoordinator ASYNC] Hiding WaitingDialog before showing End Dialog.");
                     waitingDialog.hide(); // Use hide() instead of close() if that's the method
                 }
                 // --- END HIDE Waiting Dialog ---

                 // --- Show Appropriate End Dialog ---
                 if (mode === 'single') {
                     console.log("[GameCoordinator ASYNC] Requesting UIManager show Single Player End Dialog.");
                     
                     // *** Construct payload assuming finalResults is valid (NO extra validation here) ***
                     const dialogData = {
                         // Pass existing top-level properties 
                         score: finalResults.score,
                         playerName: finalResults.playerName,
                         correctAnswers: finalResults.correctAnswers,
                         totalQuestions: finalResults.totalQuestions,
                         eligibleForHighscore: finalResults.eligibleForHighscore,
                         // Assign difficulty and constructed gameName directly from settings
                         difficulty: finalResults.settings.difficulty, 
                         gameName: finalResults.settings.sheetIds.join(', '),
                         mode: 'single' // Explicitly set mode for the dialog
                     };
                     // *** END CONSTRUCTION ***
                     
                     eventBus.emit(Events.Navigation.ShowView, {
                         viewName: Views.SinglePlayerEndDialog,
                         data: dialogData // Use the constructed data object
                     });
                 } else if (mode === 'multiplayer-host') {
                      console.log("[GameCoordinator ASYNC] Processing Multiplayer Host finish.");

                      // --- SAVE Multiplayer Highscore (WINNER ONLY) ---
                      if (finalResults && finalResults.winner && finalResults.winner.score > 0) {
                          const winner = finalResults.winner;
                          console.log(`[GameCoordinator ASYNC] Multiplayer winner: ${winner.name}, Score: ${winner.score}. Attempting to save highscore.`);
                          try {
                              // CORRECTED: Use the correct method name 'addHighscore'
                              highscoreManager.addHighscore(
                                  winner.name,
                                  winner.score,
                                  finalResults.gameName || 'Multiplayer Game',
                                  'multiplayer', // Set mode correctly
                                  finalResults.difficulty || 'unknown'
                              );
                              console.log("[GameCoordinator ASYNC] Highscore save request sent for winner.");
                          } catch (error) {
                               console.error(`[GameCoordinator ASYNC] Error saving highscore for winner ${winner.name}:`, error);
                               eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('hsSaveErrorGeneric') || 'Failed to save score.', level: 'error' });
                          }
                      } else {
                          console.log("[GameCoordinator ASYNC] No single winner found or winner score is 0. No highscore saved.");
                      }
                      // --- END SAVE Multiplayer Highscore ---

                      // --- Show Multiplayer End Dialog ---
                      console.log("[GameCoordinator ASYNC] Requesting UIManager show Multiplayer End Dialog.");
                      eventBus.emit(Events.Navigation.ShowView, {
                          viewName: Views.MultiplayerEndDialog,
                          data: finalResults || {}
                      });
                      // --- END Show Multiplayer End Dialog ---

                 } else if (mode === 'practice') {
                     console.log("[GameCoordinator ASYNC] Requesting UIManager show PracticeEndDialog.");
                     eventBus.emit(Events.Navigation.ShowView, {
                         viewName: Views.PracticeEndDialog,
                         data: finalResults || {}
                     });
                 }
                 // --- End Show Appropriate End Dialog ---

                 // Close connection if host finished
                 if (mode === 'multiplayer-host') {
                     console.log("[GameCoordinator ASYNC] Closing WebRTC connection after Host game finished and processed.");
                     webRTCManager.closeConnection();
                 }

            } else {
                 // Client finished locally - wait for GAME_OVER
                 console.log(`[GameCoordinator ASYNC] Client finished locally. Waiting for GAME_OVER from host for final cleanup.`);
            }
        } else {
            console.warn("[GameCoordinator ASYNC] Game.Finished received, but no active game found.");
            // Ensure connection is closed if necessary based on mode
             if (mode === 'multiplayer-host' || mode === 'multiplayer-client') {
                 webRTCManager.closeConnection();
             }
        }
    }

    /**
     * Handles the user explicitly leaving the game.
     * @private
     */
    handleLeaveGame() {
        console.log("[GameCoordinator] Received request to leave game.");
        if (this.activeGame) {
            console.log("[GameCoordinator] Destroying active game due to leave request.");
            
            // --- Provide feedback on leave --- 
            const mode = this.currentGameMode; // Get current mode before destroying
            if (typeof this.activeGame.destroy === 'function') {
                 this.activeGame.destroy(); // This now sends CLIENT_LEFT if applicable
             }
            this.activeGame = null;
            this.currentGameMode = null;

            // Show feedback AFTER attempting destruction/notification
            let feedbackKey = 'gameLeftFeedbackGeneric';
            if (mode === 'multiplayer-client') {
                 feedbackKey = 'gameLeftFeedbackClient';
            } else if (mode === 'multiplayer-host') {
                 feedbackKey = 'gameLeftFeedbackHost';
            }
            const feedbackMessage = miscUtils.getTextTemplate(feedbackKey);
            if (feedbackMessage) {
                eventBus.emit(Events.System.ShowFeedback, { message: feedbackMessage, level: 'info' });
            }
            // --- End Feedback ---

            // Navigate immediately back to main menu
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            // WebRTC connection is closed within the game's destroy() method now
            // webRTCManager.closeConnection(); 
        } else {
            console.warn("[GameCoordinator] LeaveGame request received, but no active game found.");
             // Ensure navigation back if somehow stuck
             eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
        }
    }

    /**
     * Handles WebRTC connection failures reported by WebRTCManager.
     * @param {object} payload - Event payload from Events.WebRTC.ConnectionFailed
     * @param {Error} payload.error - The error object.
     * @param {string} payload.context - Context where failure occurred.
     * @param {string} [payload.peerId] - Peer ID involved, if applicable.
     * @private
     */
    handleWebRTCConnectionFailure({ error, context, peerId }) {
        console.error(`[GameCoordinator] WebRTC Connection Failure. Context: ${context}, Peer: ${peerId}`, error);
        // Clean up any pending operations
        this.pendingHostInfo = null;
        this.pendingJoinInfo = null;
        // If a game was active, destroy it (though maybe WebRTCManager already did?)
        if (this.activeGame) {
            console.warn("[GameCoordinator] Destroying active game due to WebRTC failure.");
             if (this.activeGame && typeof this.activeGame.destroy === 'function') {
                  this.activeGame.destroy();
              }
            this.activeGame = null;
        }
        // Ensure connection is closed by WebRTCManager
        webRTCManager.closeConnection(); 
        
        // Show appropriate error dialog based on context
        let errorKey = 'errorDialogGenericConnection'; // Default key
        if (error.type === 'peer-unavailable') {
            errorKey = 'errorDialogHostUnavailable'; 
        } else if (error.type === 'network' || error.message === 'Lost connection to signaling server.') {
            errorKey = 'errorDialogNetwork';
        }
        
        /** @type {ErrorDialog} */
        const errorDialog = uiManager.getComponent('ErrorDialog'); // Use hardcoded name
        if (errorDialog) {
            // Construct the message string before showing
            const baseMessage = miscUtils.getTextTemplate(errorKey);
            // Show ONLY the user-friendly message in the dialog
            errorDialog.show(baseMessage);
        } else {
            // Fallback if dialog isn't available
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate(errorKey), level: 'error' });
        }

        // Ensure UI is back at the main menu *after* showing the dialog
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
    }

    /**
     * Resets the coordinator's internal state.
     * @private
     */
    resetCoordinatorState() {
        console.log("[GameCoordinator ASYNC] Resetting state...");
        this.pendingHostInfo = null;
        this.pendingJoinInfo = null;
        // Only destroy activeGame if it hasn't been handled already
        if (this.activeGame && typeof this.activeGame.destroy === 'function') {
            console.warn("[GameCoordinator ASYNC] resetCoordinatorState called with active game - destroying.");
             this.activeGame.destroy(); 
        }
        if (this.activeHostManager && typeof this.activeHostManager.destroy === 'function') {
             this.activeHostManager.destroy();
        }
        this.activeGame = null;
        this.currentGameMode = null;
        this.activeHostManager = null; 
        webRTCManager.closeConnection();
        console.log("[GameCoordinator ASYNC] State reset complete.");
    }

    // --- New method to handle player list updates and forward to UI ---
    /**
     * Handles player list updates from MultiplayerHostManager.
     * Updates the Host Lobby component if it's active.
     * @param {object} payload - From Events.Multiplayer.Common.PlayerListUpdated.
     * @param {Map<string, object>} payload.players - The updated player map.
     * @private
     */
    _handlePlayerListUpdate({ players }) {
        // Only relevant if this instance is potentially hosting (pendingHostInfo exists)
        if (this.pendingHostInfo) {
            /** @type {HostLobbyComponent | undefined} */
            const hostLobbyComp = uiManager.getComponent('HostLobby');
            if (hostLobbyComp && hostLobbyComp.isVisible) {
                 console.debug("[GameCoordinator] Forwarding PlayerListUpdate to HostLobbyComponent.", players);
                 hostLobbyComp.updateDisplay(players);
            } else {
                 console.debug("[GameCoordinator] Received PlayerListUpdate, but HostLobbyComponent not visible or found.");
            }
        }
    }

    // New method to handle connection events from WebRTCManager
    _handleClientConnectedToHost({ hostId }) {
        console.log(`[GameCoordinator] Client connected to host. Host ID: ${hostId}`);
        // Connection is open, but we wait for GAME_INFO before sending c_requestJoin
        // This ensures the host has our initial player entry from metadata
        // before we try to update the name.
    }

    /**
     * Handles incoming raw WebRTC messages for the CLIENT.
     * Starts game on GAME_START, handles GAME_OVER (saves score, triggers final cleanup via dialog).
     * @private
     */
    async _handleWebRTCMessageReceived({ msg, sender }) {
        if (!msg || !msg.type || this.webRTCManager.isHost) return;
        const type = msg.type;
        const payload = msg.payload;
        const hostId = this.pendingJoinInfo?.hostId || this.webRTCManager.hostPeerId;
        if (sender !== hostId) { /* ... warning ... */ return; }
        // console.log(`[GameCoordinator Client ASYNC] Received message Type: ${type} from Host ${sender}`); // Reduce noise

        switch (type) {
            case MSG_TYPE.GAME_START:
                console.log(`[GameCoordinator] Received GAME_START from host ${sender}`);

                // Ensure we are in a state expecting a game start (i.e., pending join)
                if (!this.pendingJoinInfo || this.pendingJoinInfo.hostId !== sender) {
                    console.warn("[GameCoordinator] Received GAME_START, but not in a valid pending join state or hostId mismatch.", { pendingHost: this.pendingJoinInfo?.hostId, receivedHost: sender });
                    // Ignore if we weren't expecting this host to start a game for us.
                    return;
                }

                // Fetch game data and difficulty STASHED during join process
                const storedInfo = this.pendingJoinInfo; // Get the stored info object

                // --- NO OPTIONAL CHAINING: Rely on prior null check --- 
                const gameData = storedInfo.questionsData; // Read directly using correct property name
                const difficulty = storedInfo.difficulty;   // Read directly
                const playerName = storedInfo.playerName;   // Already correct
                const hostId = storedInfo.hostId;         // Already correct
                // --- END CORRECTION ---

                // Verify we have everything needed
                if (!playerName || !hostId || !gameData || !difficulty) {
                    // Keep this detailed log for debugging if issues persist
                     console.error("[GameCoordinator] GAME_START received, but essential pending join info is missing!", 
                                   { pendingJoinInfo: storedInfo, // Log the whole object
                                     hasPlayerName: !!playerName, 
                                     hasHostId: !!hostId, 
                                     hasGameData: !!gameData, // Check the corrected variable
                                     hasDifficulty: !!difficulty }); // Check the corrected variable
                    
                     eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('mpClientErrorMissingJoinData'), level: 'error' });
                     this.resetCoordinatorState(); // Clean up failed join attempt
                     eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu }); // Go back to safety
                    return;
                }

                console.log(`[GameCoordinator] All required info present for GAME_START. Starting client game instance.`);
                // Show loading temporarily? Client should be on MultiplayerLobby view.
                // No, client stays on the waiting lobby until Game.Started -> GameArea navigation

                // Start the CLIENT-side MultiplayerGame instance
                await this.startMultiplayerGameInstance(
                    false,          // isHost = false
                    playerName,
                    gameData,       // Pass the questions data object
                    difficulty,
                    hostId          // Pass the host's ID
                );

                // Clear the pending join info AFTER successfully starting the game instance
                // (startMultiplayerGameInstance sets this.activeGame)
                if (this.activeGame) {
                    console.log("[GameCoordinator] Client game instance started, clearing pendingJoinInfo.");
                    this.pendingJoinInfo = null; 
                } else {
                    // This case should be handled inside startMultiplayerGameInstance (it navigates to MainMenu)
                    console.error("[GameCoordinator] Failed to start client game instance after GAME_START, pendingJoinInfo not cleared.");
                }
                break;

            case MSG_TYPE.GAME_OVER:
                console.log(`[GameCoordinator Client ASYNC] Received GAME_OVER.`, payload);

                // *** Hide the WaitingDialog FIRST ***
                const waitingDialog = uiManager.getComponent('WaitingDialog');
                if (waitingDialog) {
                    waitingDialog.hide();
                }

                // Stop active client game if it exists
                if (this.activeGame && !this.activeGame.isFinished) {
                    // Ensure client game resources are cleaned up (e.g., timers)
                    this.activeGame.finishGame(true); // Use flag to signal final cleanup
                }

                // Save just the local player's score if they're playing
                if (this.localPlayerName) {
                    console.log(`[GameCoordinator Client ASYNC] Game over. Saving local player score.`);
                    try {
                        // Ensure all necessary data is present for saving
                        if (payload.gameName && payload.difficulty && typeof this.activeGame?.score === 'number') {
                            await highscoreManager.addHighscore(
                                this.localPlayerName,
                                this.activeGame.score,
                                payload.gameName, 
                                'multiplayer', // Use generic mode
                                payload.difficulty
                            );
                            console.log("[GameCoordinator Client ASYNC] Local player's highscore saved.");
                        } else {
                            console.warn("[GameCoordinator Client ASYNC] Missing data required to save local highscore on GAME_OVER.");
                        }
                    } catch (error) {
                        console.error("[GameCoordinator Client ASYNC] Error saving local highscore on GAME_OVER:", error);
                        eventBus.emit(Events.System.ShowFeedback, { message: 'Error saving local highscore.', level: 'error' });
                    }
                }

                // Show MultiplayerEndDialog for the client
                console.log("[GameCoordinator Client ASYNC] Requesting UIManager show MultiplayerEndDialog for Client.");
                eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MultiplayerEndDialog, data: payload });

                // Reset coordinator state related to the active game
                this.activeGame = null; // Nullify active game *after* processing GAME_OVER
                this.currentGameMode = null;
                break;

            // Handle dedicated score update message from host
            case MSG_TYPE.H_PLAYER_SCORES_UPDATE:
                console.log(`[GameCoordinator Client ASYNC] Received player scores update from host`, payload);
                
                // Check if this contains the winner information
                if (payload.winner && payload.winner.name && typeof payload.winner.score === 'number') {
                    try {
                        console.log(`[GameCoordinator Client ASYNC] Saving winner's (${payload.winner.name}) score: ${payload.winner.score}`);
                        if (payload.gameName && payload.difficulty) {
                            await highscoreManager.addHighscore(
                                payload.winner.name,
                                payload.winner.score,
                                payload.gameName,
                                'multiplayer',
                                payload.difficulty
                            );
                            console.log(`[GameCoordinator Client ASYNC] Winner's highscore saved successfully.`);
                        } else {
                            console.warn("[GameCoordinator Client ASYNC] Missing game info for saving winner's score", payload);
                        }
                    } catch (error) {
                        console.error("[GameCoordinator Client ASYNC] Error saving winner's highscore:", error);
                    }
                }
                
                // Update player list if applicable
                if (payload.players) {
                    this._handlePlayerListUpdate({ players: payload.players });
                }
                break;

            case MSG_TYPE.PLAYER_LIST_UPDATE:
                // Handle lobby updates if client is still in the lobby view
                if (this.pendingJoinInfo && !this.activeGame) {
                     /** @type {MultiplayerLobbyDialog | undefined} */
                    const lobbyDialog = uiManager.getComponent('MultiplayerLobbyDialog');
                    if (lobbyDialog && lobbyDialog.isVisible && payload && payload.players) {
                         try {
                             const playersMap = new Map(Object.entries(payload.players));
                             lobbyDialog._renderPlayerList(playersMap, webRTCManager.getMyPeerId());
                         } catch (mapError) {
                             console.error("[GameCoordinator Client ASYNC] Error parsing player list update:", mapError, payload.players);
                         }
                    }
                }
                 break;

            // <<< Handle Host Restarting Lobby for Rematch >>>
            case MSG_TYPE.H_RESTARTING_LOBBY:
                console.log("[GameCoordinator Client ASYNC] Host signaled lobby restart for rematch.");
                // Navigate back to the lobby dialog view
                eventBus.emit(Events.Navigation.ShowView, {
                     viewName: Views.MultiplayerLobby,
                     // Pass the current player list if available? Or let lobby fetch?
                     // data: { players: this.currentPlayerList } 
                });
                // Clear any previous active game state if necessary (should be null already)
                this.activeGame = null;
                this.currentGameMode = null;
                break;
            // <<< End Handle Lobby Restart >>>

            default:
                // Log unexpected types, but don't error out
                console.log(`[GameCoordinator Client ASYNC] Received unhandled message type '${type}' from host ${sender}.`);
        }
    }

    /**
     * Handles the local client finishing their game.
     * Sends CLIENT_FINISHED message to host (done in MultiplayerGame)
     * and shows the waiting dialog.
     * @param {object} payload - From Events.Game.LocalPlayerFinished
     * @param {number} payload.score - The final score achieved by the local client.
     * @private
     */
    _handleLocalPlayerFinished({ score }) {
         console.log(`[GameCoordinator Client ASYNC] LocalPlayerFinished event received. Final score: ${score}`);
         if (this.currentGameMode !== 'multiplayer-client' || !this.activeGame) {
             console.warn("[GameCoordinator Client ASYNC] LocalPlayerFinished ignored: not in active client game mode or game inactive.");
             return;
         }

         // Show waiting dialog - keep it simple
         const waitingDialog = uiManager.getComponent('WaitingDialog');
         if (waitingDialog) {
             const waitMessage = miscUtils.getTextTemplate('mpClientWaitOthers') || "Je bent klaar! We wachten op de andere spelers";
             waitingDialog.show(waitMessage);
         } else {
             console.error("[GameCoordinator Client ASYNC] WaitingDialog component not found!");
             eventBus.emit(Events.System.ShowFeedback, { 
                 message: 'Je bent klaar! Wachten op anderen...', 
                 level: 'info',
                 duration: 8000
             });
         }
     }

    /**
     * Handles the request to save a highscore, typically from the SinglePlayerEndDialog.
     * Validates data, calls the HighscoreManager, provides feedback, and navigates.
     * Now uses arrow function syntax for automatic `this` binding and is async.
     * @param {object} payload - Event payload from Events.UI.EndDialog.SaveScoreClicked
     * @param {string} [payload.playerName]
     * @param {number} [payload.score]
     * @param {string} [payload.gameName]
     * @param {string} [payload.mode]
     * @param {string} [payload.difficulty]
     * @private
     */
    handleSaveHighscore = async (payload) => { // Accept the whole payload object
        console.log(`[GameCoordinator] Received request to save highscore:`, payload); // Log the entire payload

        // *** CORRECTED CHECK: Use the mode from the event payload ***
        if (payload.mode !== 'single') { 
            console.warn(`[GameCoordinator] handleSaveHighscore called, but event payload mode is not 'single' (Mode: ${payload.mode}). Ignoring.`);
            // This prevents saving scores if the event somehow comes from a non-single-player context.
            return; 
        }

        // --- Strengthened Validation ---
        // Access properties via the payload object
        const isValid = payload.name && typeof payload.name === 'string' && payload.name.trim() !== '' && // Use payload.name
                        payload.score !== undefined && typeof payload.score === 'number' && payload.score >= 0 && // Added score >= 0 check
                        payload.gameName && typeof payload.gameName === 'string' &&
                        payload.difficulty && typeof payload.difficulty === 'string';

        if (!isValid) {
            console.error("[GameCoordinator] Attempted to save highscore with invalid or incomplete data.", payload);
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('hsSaveErrorInvalidData') || 'Fout bij opslaan: Ongeldige gegevens.', level: 'error' });
            // Navigate back to main menu even on error to avoid getting stuck?
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            return;
        }

        // --- Perform Save, Feedback, and Navigation (Single-Player ONLY) ---
        try {
            console.log("[GameCoordinator] Saving highscore for single-player game...");
            // Call the correct method on the manager instance using payload properties
            await highscoreManager.addHighscore(payload.name, payload.score, payload.gameName, payload.mode, payload.difficulty); // Use payload.name
            eventBus.emit(Events.System.ShowFeedback, { message: 'Highscore opgeslagen!', level: 'success' }); // Use appropriate message
        } catch (error) {
            console.error("[GameCoordinator] Error saving highscore:", error);
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('hsSaveError') || 'Kon highscore niet opslaan.', level: 'error' });
            // Optionally, add more specific error messages based on error type
        } finally {
            // Always navigate back to main menu after attempting save (success or fail) in single player
            console.log("[GameCoordinator] Navigating back to Main Menu after save attempt.");
            eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
            // Also ensure game state is fully reset if needed after SP game
            this.resetCoordinatorState(); 
        }
    }

    /** 
     * Tries to load the player name from localStorage.
     * If not found, generates a new random name and saves it.
     * @private 
     */
    _loadPlayerName() {
        let name = localStorage.getItem('playerName');
        if (!name) {
            // Use the CORRECT function name via miscUtils default import
            name = miscUtils.generateRandomPlayerName(); 
            this._savePlayerName(name); // Save the generated name
        }
        this.localPlayerName = name;
        console.log(`[GameCoordinator] Player name set to: ${this.localPlayerName}`);
    }

    /** Saves the player name to localStorage. @private */
    _savePlayerName(name) {
        if (name && typeof name === 'string') {
            //localStorage.setItem('playerName', name);
        } else {
            console.warn("[GameCoordinator] Attempted to save invalid player name.");
        }
    }

    // +++ ADDED: Handler for Host Waiting +++
    /**
     * Handles the event when the host is waiting for clients to finish.
     * @param {object} payload - The payload from the HostWaiting event.
     * @param {string} [payload.messageKey] - Optional message key for translation.
     * @private
     */
    _handleHostWaiting(payload) {
        console.log(`[GameCoordinator DEBUG] _handleHostWaiting called with payload:`, payload);
        console.log(`[GameCoordinator DEBUG] Current game mode: ${this.currentGameMode}, Active game exists: ${!!this.activeGame}`);

        // If game is not active, don't show dialog
        if (!this.activeGame) {
            console.log("[GameCoordinator] _handleHostWaiting called, but game is not active. Ignoring.");
            return;
        }

        // Different message template based on role
        const messageKey = this.currentGameMode === 'multiplayer-host' ? 
                          'mpHostWaitOthers' : 'mpClientWaitOthers';
        const message = miscUtils.getTextTemplate(payload?.messageKey || messageKey) || "Waiting for other players...";

        console.log(`[GameCoordinator] ${this.currentGameMode} waiting for others. Showing WaitingDialog with message: "${message}"`);

        /** @type {import('../dialogs/waiting-dialog.js').default | undefined} */
        const waitingDialog = uiManager.getComponent('WaitingDialog');
        console.log(`[GameCoordinator DEBUG] WaitingDialog component found: ${!!waitingDialog}`);
        
        if (waitingDialog) {
            try {
                waitingDialog.show(message);
                console.log("[GameCoordinator] WaitingDialog shown. Current isOpen state:", waitingDialog.isOpen);
            } catch (error) {
                console.error("[GameCoordinator] Error showing WaitingDialog:", error);
            }
        } else {
            console.error("[GameCoordinator] WaitingDialog component not found.");
        }
    }
    // --- END CHANGE ---

    /**
     * Handles the closing of the Multiplayer End Dialog.
     * Performs final state cleanup and navigates to the main menu.
     * @private
     */
    _handleMultiplayerDialogClosed() {
        console.log("[GameCoordinator] MultiplayerEndDialog closed. Cleaning up multiplayer state if needed.");

        // <<< Explicitly hide WaitingDialog FIRST >>>
        try {
            const waitingDialog = uiManager.getComponent('WaitingDialog');
            if (waitingDialog && waitingDialog.isOpen) { 
                console.log("[GameCoordinator] Force-hiding WaitingDialog on MP Dialog close.");
                waitingDialog.hide();
                 // Optional: Check if it actually closed
                 if (waitingDialog.isOpen) {
                     console.warn("[GameCoordinator] WaitingDialog did NOT hide after calling hide()!");
                 }
            } else {
                 console.log("[GameCoordinator] WaitingDialog not found or not open during MP Dialog close.");
            }
        } catch (error) {
            console.error("[GameCoordinator] Error trying to hide WaitingDialog:", error);
        }
        // <<< END HIDE >>>

        // Stop the WebRTCManager's timeout check if it's running (client-side)
        if (this.webRTCManager.isClient && this.webRTCManager.status === ConnectionStatus.CONNECTED_CLIENT) { // Added status check for robustness
            console.log("[GameCoordinator] Stopping WebRTC timeout check as client left end dialog.");
            this.webRTCManager.stopTimeoutCheck(); // Assuming this method exists
        }
        
        // Optionally: Reset the client manager state if no rematch is planned immediately
        // if (this.multiplayerClientManager && this.multiplayerClientManager.isConnected()) {
        //     console.log("[GameCoordinator] Resetting MultiplayerClientManager state.");
        //     this.multiplayerClientManager.resetState();
        // }

        // Ensure any lingering game/mode state is cleared
        this.resetCoordinatorState();

        // <<< ADD NAVIGATION BACK TO MAIN MENU >>>
        console.log("[GameCoordinator] Navigating back to Main Menu after MP Dialog close.");
        eventBus.emit(Events.Navigation.ShowView, { viewName: Views.MainMenu });
    }

    /**
     * Handles the request to play again from the MultiplayerEndDialog.
     * Uses arrow function syntax for automatic `this` binding.
     * @private
     */
    _handlePlayAgainRequest = async () => { // <<< Changed to arrow function
        console.log("[GameCoordinator] Play Again requested.");
        
        if (this.webRTCManager.status !== ConnectionStatus.CONNECTED_CLIENT) { 
            console.error("[GameCoordinator] Cannot play again, not connected.");
            eventBus.emit(Events.System.ShowFeedback, { message: miscUtils.getTextTemplate('mpErrorNotConnected'), level: 'error' });
            return;
        }
    };
}

export default GameCoordinator;import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';

import QuizEngine from '../services/QuizEngine.js';
import webRTCManager from '../services/WebRTCManager.js'; // Corrected path
import { getTextTemplate } from '../utils/miscUtils.js'; // Import the utility
import { MSG_TYPE } from '../core/message-types.js'; // CORRECTED IMPORT: Use named import for MSG_TYPE
import questionsManager from '../services/QuestionsManager.js'; // Import questionsManager
import uiManager from '../ui/UIManager.js'; // Import UIManager
import Views from '../core/view-constants.js'; // Import Views for GameArea

import miscUtils from '../utils/miscUtils.js'; // Changed to default import

// Define message types used specifically by the client manager
const ClientMessageTypes = {
    REQUEST_JOIN: 'c_requestJoin',      // Client -> Host: Request to join after confirmation
    SUBMIT_ANSWER: 'c_submitAnswer',    // Client -> Host: Submit answer for current question
    FINISHED_GAME: 'c_finishedGame',    // Client -> Host: Notify host client finished quiz
    // Add other client-specific outgoing message types here if needed
};

// Define a constant for client_ready in case the import fails
const CLIENT_READY = 'client_ready';

// ADDED: Explicit debug check to ensure MSG_TYPE is properly imported
console.log(`[MultiplayerClientManager] MSG_TYPE.CLIENT_READY = "${MSG_TYPE.CLIENT_READY || CLIENT_READY}"`);

/**
 * Manages the client-side state and interactions during a multiplayer game.
 * Listens for game data received from the host (via WebRTCManager) and
 * translates it into local events for UI components. Also handles sending
 * client actions (like submitting answers) back to the host.
 */
class MultiplayerClientManager {
    constructor() {
        console.log('[MultiplayerClientManager] Initialized');
        this.isGameActive = false;
        this.hostPeerId = null; // Store the host's ID when connected
        this._boundHandleDataReceived = this.handleDataReceived.bind(this);
        this._boundHandleAnswerSubmitted = this.handleAnswerSubmitted.bind(this); // Bind answer handler
        this._listeningForAnswers = false; // Flag to track if we are listening

        this.listen();
    }

    /**
     * Sets up listeners for relevant events.
     * @private
     */
    listen() {
        // Listen for data coming FROM the host (via WebRTCManager) - REMOVED FROM HERE
        // eventBus.on(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);

        // Listen for the client successfully connecting TO the host
        eventBus.on(Events.Multiplayer.Client.ConnectedToHost, this.handleConnectedToHost.bind(this));

        // Listen for disconnection FROM the host
        eventBus.on(Events.Multiplayer.Client.DisconnectedFromHost, this.handleDisconnectedFromHost.bind(this));

        // Listen for game start/finish to manage the AnswerSubmitted listener
        eventBus.on(Events.Game.Started, this._handleGameStarted.bind(this));
        eventBus.on(Events.Game.Finished, this._handleGameFinished.bind(this));

        // DO NOT listen for AnswerSubmitted here initially
        // eventBus.on(Events.UI.GameArea.AnswerSubmitted, this.handleAnswerSubmitted.bind(this));
    }

    /** @private */
    _startListeningForAnswers() {
        if (!this._listeningForAnswers) {
            eventBus.on(Events.UI.GameArea.AnswerSubmitted, this._boundHandleAnswerSubmitted);
            this._listeningForAnswers = true;
            console.log(`[${this.constructor.name}] Started listening for answer submissions.`);
        }
    }

    /** @private */
    _stopListeningForAnswers() {
        if (this._listeningForAnswers) {
            eventBus.off(Events.UI.GameArea.AnswerSubmitted, this._boundHandleAnswerSubmitted);
            this._listeningForAnswers = false;
            console.log(`[${this.constructor.name}] Stopped listening for answer submissions.`);
        }
    }

    /**
     * Handles Game.Started event to determine if we should listen for answers.
     * @param {object} payload
     * @param {string} payload.mode
     * @param {string} payload.role
     * @private
     */
    _handleGameStarted(payload) {
        if (payload.mode === 'multiplayer' && payload.role === 'client') {
            this.startGame(this.hostPeerId); // Mark game active (might be redundant if startGame called elsewhere)
            this._startListeningForAnswers();
        } else {
            // If game started but not MP client, ensure we are NOT listening
            this._stopListeningForAnswers();
        }
    }

    /**
     * Handles Game.Finished event to stop listening for answers.
     * @param {object} payload
     * @param {string} payload.mode
     * @private
     */
    _handleGameFinished(payload) {
        // Stop listening regardless of which mode finished, just in case
        this._stopListeningForAnswers();
        // Reset internal state if it was a multiplayer game ending
        if (payload.mode === 'multiplayer') {
            this.resetState();
        }
    }

    /**
     * Handles the event when connection to the host is established.
     * @param {object} payload - Event payload.
     * @param {string} payload.hostId - The PeerJS ID of the host.
     */
    handleConnectedToHost({ hostId }) {
        console.log(`[MultiplayerClientManager] Connected to host: ${hostId}`);
        this.hostPeerId = hostId;
        // Start listening for messages FROM this specific host NOW
        eventBus.on(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);
        // Ready to receive game info, but game hasn't necessarily started.
        // The JoinLobby or Coordinator should manage the transition to the game view.
    }

    /**
     * Handles disconnection from the host.
     * @param {object} [payload] - Optional event payload.
     * @param {string} [payload.reason] - Optional reason for disconnection.
     */
    handleDisconnectedFromHost(payload) {
        console.warn('[MultiplayerClientManager] Disconnected from host.', payload?.reason || '');
        const wasActive = this.isGameActive;
        this._stopListeningForAnswers(); // Stop listening on disconnect

        // *** ADDED: Stop listening for WebRTC messages on disconnect ***
        eventBus.off(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);

        this.resetState(); // Reset internal state (also ensures listener is off if called directly)
        // UI should react to DisconnectedFromHost or a specific Game.Finished/Error event
        // Emitting a generic error or feedback might be appropriate here.
        // Use template for feedback message
        eventBus.emit(Events.System.ShowFeedback, { message: getTextTemplate('mcDisconnect'), level: 'warn' });
        // Potentially emit a game finished event if the game was active
        if (wasActive) {
             // Let _handleGameFinished manage state reset if event is emitted
             // eventBus.emit(Events.Game.Finished, { mode: 'multiplayer', results: { disconnected: true } });
             // No, Game.Finished should signify a *natural* end. Disconnect is different.
        }
         // TODO: Trigger navigation back to main menu or appropriate screen?
         // This might be handled by UIManager listening to DisconnectedFromHost or Game.Finished
    }

    /**
     * Marks the client game as active. Called by GameCoordinator or similar.
     * @param {string} hostId - The ID of the host peer.
     */
    startGame(hostId) {
        console.log(`[MultiplayerClientManager] Starting client game with host: ${hostId}`);
        this.isGameActive = true;
        this.hostPeerId = hostId;
        // Initial state is set, waiting for data from host (e.g., first question)
    }

    /**
     * Resets the manager's state, typically on game end or disconnection.
     * @private
     */
    resetState() {
        // *** ADDED: Ensure WebRTC message listener is off during reset ***
        eventBus.off(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);

        this.isGameActive = false;
        this.hostPeerId = null;
        console.log('[MultiplayerClientManager] State reset.');
    }

    /**
     * Handles incoming WebRTC data messages received via the EventBus.
     * Correctly destructures the event payload { msg, sender }.
     * @param {object} eventPayload - The payload from Events.WebRTC.MessageReceived.
     * @param {object} eventPayload.msg - The actual message object { type, payload }.
     * @param {string} eventPayload.sender - The peer ID of the sender (the host).
     * @private
     */
    handleDataReceived({ msg, sender }) { // Destructure the event payload here
        const data = msg;
        const senderId = sender;

        if (!data || typeof data.type !== 'string' || !data.type) {
            console.warn(`[MultiplayerClientManager] Received invalid data structure from host ${senderId}:`, data);
            return;
        }

        // Verify sender is the expected host
        const expectedHostId = this.hostPeerId;
        if (!expectedHostId) {
             // This case handles receiving a message before the handleConnectedToHost method has set this.hostPeerId
             console.warn(`[MultiplayerClientManager] Received message from ${senderId}, but client manager has no expected host ID set yet.`);
             // Optionally, could try webRTCManager.hostPeerId if that's maintained, but using local state is cleaner
             return;
        }
        if (senderId !== expectedHostId) {
             console.warn(`[MultiplayerClientManager] Received message from unexpected sender ${senderId} (expected host ${expectedHostId}). Ignoring.`);
             return;
        }

        // console.log(`[MultiplayerClientManager] Received data from host (${senderId}): Type=${data.type}`, data.payload); // Reduce log noise

        const { type, payload } = data; // Destructure the inner 'data' object

        switch (type) {
            case MSG_TYPE.GAME_INFO:
                let reconstructedPlayersMap = new Map();
                if (payload && payload.players && typeof payload.players === 'object') {
                    reconstructedPlayersMap = new Map(Object.entries(payload.players));
                    // console.log('[MultiplayerClientManager DEBUG] Reconstructed players map:', reconstructedPlayersMap);
                    // console.log('[MultiplayerClientManager DEBUG] Expecting host ID:', payload.hostId); // Host ID is in payload here
                }

                const gameInfoPayload = {
                    questionsData: payload.questions,
                    difficulty: payload.difficulty,
                    players: reconstructedPlayersMap,
                    hostId: payload.hostId // Use hostId from the payload
                };
                // Only emit if the host ID in the payload matches the connected host
                if (gameInfoPayload.hostId === expectedHostId) {
                    eventBus.emit(Events.Multiplayer.Client.GameInfoReceived, gameInfoPayload);
                } else {
                     console.warn(`[MultiplayerClientManager] Received GAME_INFO for a different host (${gameInfoPayload.hostId}) than connected (${expectedHostId}). Ignoring.`);
                     return; // Don't process game info for the wrong host
                }

                // Attempt to save received custom sheets locally
                try {
                    if (gameInfoPayload.questionsData && Array.isArray(gameInfoPayload.questionsData.sheets)) {
                         const hostPlayer = reconstructedPlayersMap.get(gameInfoPayload.hostId);
                         const hostName = hostPlayer ? hostPlayer.name : 'Unknown Host';

                         gameInfoPayload.questionsData.sheets.forEach(sheet => {
                             if (sheet.isCustom) {
                                 questionsManager.addReceivedCustomSheet(sheet, hostName);
                             }
                         });
                    }
                } catch (saveError) {
                    console.error("[MultiplayerClientManager] Error trying to save received custom sheets:", saveError);
                }
                break;

            case MSG_TYPE.PREPARE_GAME:
                console.log("[MultiplayerClientManager] Received PREPARE_GAME from host.", payload);
                if (payload && payload.duration) {
                    // Emit the local event to start the countdown UI
                    eventBus.emit(Events.Game.CountdownStart, { 
                        duration: payload.duration, 
                        // Ensure the standard completion event is specified 
                        // so GameCoordinator knows when to start the actual game instance logic
                        completionEvent: Events.Game.CountdownComplete 
                    });
                    // Client game instance will be started AFTER countdown via 
                    // GameCoordinator._handleCountdownComplete
                } else {
                    console.error("[MultiplayerClientManager] Invalid PREPARE_GAME payload:", payload);
                    // Handle error - maybe disconnect or show feedback?
                }
                break;

            case MSG_TYPE.GAME_START:
                console.log(`[${this.constructor.name}] Received GAME_START from host.`);
                
                // Hide waiting dialog before navigating
                const waitingDialog = uiManager.getComponent('WaitingDialog');
                if (waitingDialog) {
                    waitingDialog.hide();
                }

                // Navigate to the GameArea view
                console.log(`[${this.constructor.name}] Navigating to GameArea.`);
                eventBus.emit(Events.Navigation.ShowView, { viewName: Views.GameArea });
                break;

            case 'question_new':
                // Payload example: { questionIndex: number, totalQuestions: number, questionData: {...} }
                eventBus.emit(Events.Game.QuestionNew, payload);
                break;

            case 'answer_result': // Host sending back result of *our* submitted answer
                // Payload example: { isCorrect: boolean, scoreDelta: number, correctAnswer: string, submittedAnswer: any, totalScore: number }
                 // Note: Emitting AnswerChecked might be confusing as it's usually internal to QuizEngine.
                 // We primarily care about the score update and potentially showing correct/incorrect feedback.
                const myResult = payload.isCorrect[webRTCManager.getMyPeerId()];
                const myScoreDelta = payload.scoreDelta[webRTCManager.getMyPeerId()];
                const myTotalScore = payload.totalScores[webRTCManager.getMyPeerId()];

                if (myTotalScore !== undefined) {
                    eventBus.emit(Events.Game.ScoreUpdated, { totalScore: myTotalScore });
                }
                // Emit a specific event for UI to show Correct/Incorrect based on *this* client's answer
                 eventBus.emit('multiplayer:client:answerResult', {
                     isCorrect: myResult,
                     correctAnswer: payload.correctAnswer,
                     // submittedAnswer: ?? // Host might not send this back
                     scoreDelta: myScoreDelta
                 });
                break;

            case 'round_results': // Host sending results after everyone answered or time ran out
                // Payload example: { scores: Map<string, number>, correctAnswers: {...}, /* other round summary */ }
                // TODO: Define and emit an appropriate event for displaying round results/leaderboard update.
                console.log('[MultiplayerClientManager] Round results received:', payload);
                 eventBus.emit('multiplayer:client:roundResults', payload);
                break;

            case 'player_update': // Another player's state changed (score, finished status)
                // Payload example: { peerId: string, updatedData: { score: number, isFinished: boolean } }
                eventBus.emit(Events.Multiplayer.Common.PlayerUpdated, payload);
                // PlayerListComponent should listen for PlayerUpdated and refresh specific player
                break;

             case 'player_list_update': // Full refresh of the player list
                 // --- ADDED DEBUG LOG --- 
                 console.debug(`[${this.constructor.name}] Received player_list_update from host. Payload:`, payload);
                 // --- END DEBUG LOG ---
                 if (payload.players && typeof payload.players === 'object') {
                     const updatedPlayersMap = new Map(Object.entries(payload.players));
                     console.log(`[${this.constructor.name}] Emitting PlayerListUpdated event.`, updatedPlayersMap);
                     eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: updatedPlayersMap });
                     // TODO: Maybe update localPlayerId if it changed? Not likely needed here.
                 } else {
                      console.warn(`[${this.constructor.name}] Received player_list_update without valid players object.`, payload);
                 }
                 break;

            case MSG_TYPE.GAME_OVER:
                // Payload example: { results: { rankings: [...], scores: {...} } }
                this.isGameActive = false;
                // Remove redundant Game.Finished emission. Coordinator handles GAME_OVER.
                // eventBus.emit(Events.Game.Finished, { mode: 'multiplayer', results: payload }); 
                this.resetState(); // Reset host ID etc.
                break;

            case 'timer_tick':
                // Payload example: { remainingTime: number }
                eventBus.emit(Events.Game.TimeTick, payload);
                break;

             case 'timer_up':
                 // Payload example: {} or { timerId: '...' }
                 eventBus.emit(Events.Game.TimeUp, payload);
                 break;

             case MSG_TYPE.ERROR:
                // Host reported an error
                // Payload example: { message: string, context?: string }
                eventBus.emit(Events.System.ErrorOccurred, {
                    message: `Error from host: ${payload.message}`,
                    context: payload.context || 'Multiplayer Game (Host)',
                });
                break;

             case 'feedback':
                  // Host wants to show feedback to this client
                  // Payload example: { message: string, level: 'info'|'warn'|'error'|'success', duration?: number }
                  eventBus.emit(Events.System.ShowFeedback, payload);
                  break;

              case 'player_joined': // Notification that a new player joined the lobby/game
                  // Payload example: { peerId: string, playerData: { name: string } }
                  eventBus.emit(Events.Multiplayer.Common.PlayerJoined, payload);
                  break;

              case 'player_left': // Notification that a player left
                  // Payload example: { peerId: string }
                  eventBus.emit(Events.Multiplayer.Common.PlayerLeft, payload);
                  break;

            // Host broadcasts this when a new player joins *during the lobby phase*
            case MSG_TYPE.PLAYER_LIST_UPDATE:
                console.log("[MultiplayerClientManager] Received PLAYER_LIST_UPDATE from host.", payload);
                if (payload && payload.players) {
                    try {
                        // Reconstruct Map from plain object
                        const playersMap = new Map(Object.entries(payload.players)); 
                        eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: playersMap });
                    } catch (mapError) {
                        console.error("[MultiplayerClientManager] Error processing PLAYER_LIST_UPDATE:", mapError, payload);
                    }
                } else {
                     console.warn("[MultiplayerClientManager] Invalid PLAYER_LIST_UPDATE payload.", payload);
                }
                break;
            
            // Host sends this when it cancels the lobby before starting
            case MSG_TYPE.FEEDBACK:
                // Forward feedback events (like lobby cancellation) to the UI
                if (payload && payload.message && payload.level) {
                    eventBus.emit(Events.System.ShowFeedback, { message: payload.message, level: payload.level });
                    // If the feedback indicates lobby closure, trigger disconnect handling
                    if (payload.message === getTextTemplate('mpHostLobbyCancelled')) {
                        this.handleDisconnectedFromHost({ reason: 'lobby_cancelled_by_host' });
                    }
                } else {
                     console.warn("[MultiplayerClientManager] Received malformed FEEDBACK message.", payload);
                }
                break;

            // --- NEW CASE ---
            case MSG_TYPE.H_PLAYER_SCORES_UPDATE:
                // Check payload directly
                if (payload && typeof payload.players === 'object' && payload.players !== null) {
                    try {
                        const playersMap = new Map(Object.entries(payload.players));
                        // console.log(`[MultiplayerClientManager] Reconstructed player scores map:`, playersMap); // Reduce noise
                        eventBus.emit(Events.Multiplayer.Common.PlayerListUpdated, { players: playersMap });
                    } catch (error) {
                         console.error('[MultiplayerClientManager] Error processing H_PLAYER_SCORES_UPDATE payload:', error, payload.players);
                    }
                } else {
                     console.warn('[MultiplayerClientManager] Invalid payload received for H_PLAYER_SCORES_UPDATE:', payload);
                }
                break;
            // --- END NEW CASE ---

            default:
                console.warn(`[MultiplayerClientManager] Received unhandled message type '${type}' from host ${senderId}.`);
        }
    }

    /**
     * Handles the local user submitting an answer. Sends it to the host via WebRTCManager.
     * @param {object} payload - The event payload from UI.GameArea.AnswerSubmitted.
     * @param {any} payload.answer - The answer submitted by the user.
     * @private
     */
    handleAnswerSubmitted({ answer }) {
        if (!this.isGameActive || !this.hostPeerId) {
            console.warn('[MultiplayerClientManager] Cannot submit answer: Game not active or host disconnected.');
            return;
        }
        console.log(`[MultiplayerClientManager] Sending answer to host: `, answer);
        // Use WebRTCManager to send the message
        webRTCManager.sendToHost('answer_submitted', { // Use type defined in MultiplayerGame for host handling
            answer: answer
        });
        // Local UI feedback (e.g., disable buttons) should be handled by the UI component
        // listening to UI.GameArea.AnswerSubmitted or 'multiplayer:client:answerResult'.
    }

    /**
     * Sends a join request to the host with the client's player name.
     * @param {string} playerName - The name the client wishes to use.
     * @throws {Error} If not connected to a host.
     */
    sendJoinRequest(playerName) {
        if (!this.hostPeerId) {
            console.error("[MultiplayerClientManager] Cannot send join request: Not connected to host.");
            throw new Error("Not connected to host.");
        }
        console.log(`[MultiplayerClientManager] Sending join request to host ${this.hostPeerId} with name: ${playerName}`);

        // Send the join request
        webRTCManager.sendToHost(ClientMessageTypes.REQUEST_JOIN, { name: playerName });
        
        // Send CLIENT_READY with explicit string type to avoid null type issues
        setTimeout(() => {
            // Use the constant directly to avoid any issues with undefined imports
            console.log(`[MultiplayerClientManager] Sending CLIENT_READY message (first attempt). Using string literal: '${CLIENT_READY}'`);
            
            // Use the explicit string to avoid any import issues
            webRTCManager.sendToHost(CLIENT_READY, { 
                name: playerName,
                isReady: true  // Explicitly include isReady flag
            });
            
            // Send a second CLIENT_READY message as backup with explicit string
            setTimeout(() => {
                console.log(`[MultiplayerClientManager] Sending CLIENT_READY message (second attempt). Using explicit string '${CLIENT_READY}'`);
                webRTCManager.sendToHost(CLIENT_READY, { 
                    name: playerName,
                    isReady: true  // Explicitly include isReady flag
                });
            }, 1000); // Try again 1 second after the first attempt
        }, 800); // Increase delay to ensure join request is fully processed first
    }

     /**
     * Cleans up listeners when the manager is no longer needed.
     * (May not be strictly necessary if it's a singleton for the app lifetime,
     * but good practice if it could be destroyed/recreated).
     */
    destroy() {
        console.log(`[${this.constructor.name}] Destroying instance.`);
        this._stopListeningForAnswers(); // Ensure listener is removed on destroy
        eventBus.off(Events.WebRTC.MessageReceived, this._boundHandleDataReceived);
        eventBus.off(Events.Multiplayer.Client.ConnectedToHost, this.handleConnectedToHost);
        eventBus.off(Events.Multiplayer.Client.DisconnectedFromHost, this.handleDisconnectedFromHost);
        eventBus.off(Events.Game.Started, this._handleGameStarted);
        eventBus.off(Events.Game.Finished, this._handleGameFinished);
        this.resetState();
    }
}

// Export a singleton instance (or manage instantiation via GameCoordinator)
const multiplayerClientManager = new MultiplayerClientManager();
export default multiplayerClientManager; import eventBus from '../core/event-bus.js';
import Events from '../core/event-constants.js';
import uiManager from '../ui/UIManager.js'; // Import UIManager to access dialogs
import { getTextTemplate } from '../utils/miscUtils.js'; // Import the new utility

// Configuration and constants
const CONFIG_PATH = './config.json'; // Path to the config file relative to index.html
const DEFAULT_SHEET_DIR = './'; // Base directory for default sheets
const CUSTOM_SHEETS_STORAGE_KEY = 'customSheets';

/**
 * Manages loading and accessing question sheet data.
 * Handles fetching default sheets (discovered via config.json) and custom sheets (localStorage).
 */
class QuestionsManager {
    constructor() {
        this.customSheets = new Map(); // Stores { id, name, questions: [{ question, answer }], isCustom: true, originHostName?: string }
        this.loadedQuestionsCache = new Map(); // Caches parsed CATEGORY OBJECTS keyed by FILE ID (e.g., 'tafels')
        this.selectableItems = []; // Holds { id: string, name: string, isCustom: boolean } for UI
        this.isInitialized = false;
        this.initializationPromise = null;
        this.initialize();

        console.info("[QuestionsManager] Instance created. Initialization started.");
    }

    /**
     * Initializes the QuestionsManager by discovering default sheets from config.json
     * and loading custom sheets from localStorage.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    async initialize() {
        if (this.initializationPromise) return this.initializationPromise;
        console.log("[QuestionsManager] Starting initialization (V1 Category Logic)...");

        this.initializationPromise = (async () => {
            this.selectableItems = []; // Reset selectable items list
            try {
                // Discover default sheets AND PARSE CATEGORIES
                await this._discoverAndParseDefaultSheets();

                // Load custom sheets and add them to selectable items
                this._loadCustomSheetsAndAddToSelectable();

                this.isInitialized = true;
                console.log(`[QuestionsManager] Initialization complete. ${this.selectableItems.length} selectable items available.`);

            } catch (error) {
                console.error("[QuestionsManager] Critical initialization error:", error);
                this.isInitialized = false;
                this.selectableItems = []; // Clear list on error
                throw error;
            }
        })();

        return this.initializationPromise;
    }

    /** Ensures initialization is complete before proceeding. */
    async _ensureInitialized() {
        if (!this.initializationPromise) {
            this.initialize();
        }
        return this.initializationPromise;
    }

    /**
     * Fetches and parses the config.json file.
     * @returns {Promise<object>} The parsed configuration object.
     * @throws {Error} If fetching or parsing fails.
     * @private
     */
    async _loadConfig() {
        console.debug(`[QuestionsManager] Fetching config from ${CONFIG_PATH}...`);
        try {
            const response = await fetch(CONFIG_PATH);
            if (!response.ok) {
                throw new Error(`HTTP error fetching config! Status: ${response.status}`);
            }
            const config = await response.json();
            console.debug("[QuestionsManager] Config loaded successfully:", config);
            return config;
        } catch (error) {
            console.error(`[QuestionsManager] Failed to load or parse config from ${CONFIG_PATH}:`, error);
            throw error;
        }
    }

    /**
     * Loads config, fetches default sheets, parses them for categories,
     * caches the full parsed data, and builds the selectable item list for categories.
     * @private
     */
    async _discoverAndParseDefaultSheets() {
        console.log(`[QuestionsManager] Discovering and parsing default sheets from ${CONFIG_PATH}...`);
        let discoveredCount = 0;
        try {
            const config = await this._loadConfig();
            if (!config || !Array.isArray(config.sheets)) {
                console.error("[QuestionsManager] Invalid or missing config.json structure.");
                return; // Stop discovery
            }

            const loadPromises = config.sheets.map(async (sheetFilename) => {
                if (typeof sheetFilename !== 'string' || !sheetFilename.endsWith('.txt')) {
                    console.warn(`[QuestionsManager] Skipping invalid sheet entry in config: ${sheetFilename}`);
                    return; // Skip this file
                }
                const fileId = sheetFilename.replace('.txt', '');
                const path = `${DEFAULT_SHEET_DIR}${sheetFilename}`;

                try {
                    // console.debug(`[QuestionsManager] Fetching ${path}...`);
                    const response = await fetch(path);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status} for ${path}`);
                    }
                    const sheetText = await response.text();
                    // Parse into category object { "Cat Name": [...] }
                    const parsedCategoryObject = this._parseSheetText(sheetText, fileId);

                    // Cache the full parsed object keyed by fileId
                    if (Object.keys(parsedCategoryObject).length > 0) {
                        this.loadedQuestionsCache.set(fileId, parsedCategoryObject);
                        // console.debug(`[QuestionsManager] Cached category object for file: ${fileId}`);

                        // Add each category title to selectableItems
                        Object.keys(parsedCategoryObject).forEach(categoryTitle => {
                            this.selectableItems.push({
                                id: `${fileId}:${categoryTitle}`, // Composite ID
                                name: categoryTitle,
                                isCustom: false
                            });
                            discoveredCount++;
                            // console.debug(`[QuestionsManager] Added selectable category: ${categoryTitle} (ID: ${fileId}:${categoryTitle})`);
                        });
                    } else {
                         console.warn(`[QuestionsManager] No categories/questions parsed from ${sheetFilename}, skipping.`);
                    }
                } catch (loadError) {
                    console.error(`[QuestionsManager] Failed to load/parse sheet ${sheetFilename}:`, loadError);
                    // Do not add to selectableItems if load/parse fails
                }
            });

            await Promise.allSettled(loadPromises); // Wait for all files to be processed
            console.log(`[QuestionsManager] Discovered and parsed ${discoveredCount} categories from default sheets.`);

        } catch (error) {
            console.error("[QuestionsManager] Error during default sheet discovery:", error);
            // Continue initialization if possible? Or re-throw?
        }
    }

    /** Loads custom sheets and adds their metadata to the selectableItems list. */
    _loadCustomSheetsAndAddToSelectable() {
        console.log("[QuestionsManager] Loading custom sheets from localStorage...");
        // Load data first (uses CUSTOM_SHEETS_STORAGE_KEY = 'customSheets')
        this._loadCustomSheets(); // This populates this.customSheets Map

        // Now add them to the selectable list
        this.customSheets.forEach((sheetData, sheetId) => {
            this.selectableItems.push({
                id: sheetId, // Use the custom sheet's unique ID
                name: sheetData.name || getTextTemplate('qmDefaultCustomName'),
                isCustom: true
            });
        });
         console.log(`[QuestionsManager] Added ${this.customSheets.size} custom sheets to selectable items.`);
    }

    /** Loads custom sheets from localStorage. */
    _loadCustomSheets() {
        console.log("[QuestionsManager] Loading custom sheets from localStorage...");
        try {
            const storedData = localStorage.getItem(CUSTOM_SHEETS_STORAGE_KEY);
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                // V2: Expecting format { sheetId: { id, name, questions, isCustom, originHostName? } }
                if (typeof parsedData === 'object' && parsedData !== null) {
                    // Directly create Map from entries, assuming stored data has correct format
                    this.customSheets = new Map(Object.entries(parsedData)); 
                    console.log(`[QuestionsManager] Loaded ${this.customSheets.size} custom sheets data.`);
                } else {
                    console.warn("[QuestionsManager] Invalid data format found in localStorage for custom sheets. Starting fresh.");
                    this.customSheets = new Map();
                    localStorage.removeItem(CUSTOM_SHEETS_STORAGE_KEY);
                }
            } else {
                // console.log("[QuestionsManager] No custom sheets found in localStorage.");
                this.customSheets = new Map();
            }
        } catch (error) {
            console.error("[QuestionsManager] Error loading custom sheets from localStorage:", error);
            this.customSheets = new Map();
        }
    }

    /** Saves the current custom sheets map to localStorage. */
    _saveCustomSheets() {
        try {
            // Convert Map to object for JSON serialization
            const objectToStore = Object.fromEntries(this.customSheets);
            localStorage.setItem(CUSTOM_SHEETS_STORAGE_KEY, JSON.stringify(objectToStore));
            console.debug("[QuestionsManager] Custom sheets saved to localStorage.");
        } catch (error) {
            console.error("[QuestionsManager] Error saving custom sheets to localStorage:", error);
            eventBus.emit(Events.System.ErrorOccurred, { message: getTextTemplate('qmSaveError'), error });
        }
    }

    /**
     * Parses text content with categories into a structured object.
     * Mimics V1 parsing logic.
     * @param {string} text - The raw text content with categories separated by double newlines.
     * @param {string} sheetIdForLogging - The sheet ID for error messages.
     * @returns {Object.<string, Array<{question: string, answer: string}>>} Object mapping category title to question array.
     * @throws {Error} If parsing fails on any line.
     * @private
     */
    _parseSheetText(text, sheetIdForLogging) {
        // V1 Parsing Logic
        const categories = text.replace(/\r/g, '').trim().split('\n\n');
        const questionsData = {};
        let firstErrorLine = -1;
        let firstErrorMessage = null;

        categories.forEach((categoryBlock, catIndex) => {
            if (firstErrorMessage) return; // Stop if error found

            const lines = categoryBlock.split('\n');
            if (lines.length === 0) return; // Skip empty blocks

            const titleLine = lines.shift();
            // Handle potential parsing issue if title line is missing or empty
            if (!titleLine) {
                 console.warn(`[QuestionsManager] Empty block or missing title in sheet '${sheetIdForLogging}', category index ${catIndex}. Skipping.`);
                 return;
            }
            const title = titleLine.trim().replace(/:$/, '').trim(); // Remove trailing colon if present
             if (!title) {
                 console.warn(`[QuestionsManager] Invalid empty title found in sheet '${sheetIdForLogging}', category index ${catIndex}. Skipping category.`);
                 return; // Skip category with empty title
            }

            questionsData[title] = []; // Initialize category array

            lines.forEach((line, lineIndex) => {
                if (firstErrorMessage) return; // Stop if error found

                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('//')) return; // Skip empty lines or comments

                const separatorIndex = trimmedLine.indexOf('=>');
                if (separatorIndex === -1 || separatorIndex === 0 || separatorIndex === trimmedLine.length - 2) {
                    // Capture error details
                    firstErrorLine = lineIndex + 1; // User-facing line number
                    // Use template for parse error, substitute line and content
                    firstErrorMessage = getTextTemplate('qmParseErrorLine', {
                        '%LINE%': firstErrorLine,
                        '%CONTENT%': trimmedLine.substring(0, 50) // Limit content length
                    });
                    return; // Stop processing lines in this category
                }

                const question = trimmedLine.substring(0, separatorIndex).trim();
                const answer = trimmedLine.substring(separatorIndex + 2).trim();
                if (question && answer) {
                    questionsData[title].push({ question, answer });
                } else {
                    // Calculate approximate original line number
                    let cumulativeLine = 1; // Start with title line
                    for(let i = 0; i < catIndex; i++) {
                       cumulativeLine += categories[i].split('\n').length + 1; // lines + newline separator
                    }
                    cumulativeLine += lineIndex + 1; // 0-based line index within category + title line offset

                    firstErrorLine = cumulativeLine
                    firstErrorMessage = `Ongeldig formaat op regel ~${firstErrorLine} in sheet '${sheetIdForLogging}' (Categorie: '${title}'): Lege vraag of antwoord.`;
                }
            });
             // Remove category if it ended up empty (e.g., only contained comments)
             if (questionsData[title].length === 0) {
                 delete questionsData[title];
             }
        });

        if (firstErrorMessage) {
            console.error(`[QuestionsManager] Parsing error: ${firstErrorMessage}`);
            throw new Error(firstErrorMessage);
        }

        if (Object.keys(questionsData).length === 0 && categories.length > 0 && categories[0].trim() !== '') {
            console.warn(`[QuestionsManager] No valid categories or questions found after parsing sheet '${sheetIdForLogging}'. Check format.`);
        }

        return questionsData; // Return the category object
    }

    // --- Custom Sheet Management ---

    /**
     * Saves a custom question sheet, either creating a new one or updating existing.
     * Parses raw text input.
     * @param {string} sheetId - The unique ID for the sheet.
     * @param {string} name - The name of the sheet.
     * @param {string} questionsText - The raw text containing questions and answers.
     * @returns {Promise<boolean>} True if save was successful, false otherwise.
     */
    async saveCustomSheetFromText(sheetId, name, questionsText) {
        await this._ensureInitialized();
        console.log(`[QuestionsManager] Attempting to save custom sheet: ${name} (${sheetId})`);

        if (!sheetId || !name || typeof questionsText !== 'string') {
            console.error("[QuestionsManager] Invalid arguments for saveCustomSheetFromText.");
            return false;
        }

        try {
            const questions = this._parseCustomQuestionsText(questionsText);
            if (questions.length === 0) {
                throw new Error("Geen geldige vragen gevonden om op te slaan.");
            }

            const newSheetData = {
                name: name,
                questions: questions,
                isCustom: true // Mark explicitly
            };

            this.customSheets.set(sheetId, newSheetData);
            this._saveCustomSheets(); // Persist to localStorage
            this._updateSelectableItems(); // Update the internal list for getAvailableSheets

            console.log(`[QuestionsManager] Custom sheet '${name}' saved successfully.`);
            return true;

        } catch (error) {
            console.error(`[QuestionsManager] Error saving custom sheet '${name}':`, error);
            // Let the coordinator handle emitting feedback/error events based on return value
            // eventBus.emit(Events.System.ErrorOccurred, { message: `Kon lijst '${name}' niet opslaan: ${error.message}`, error });
            return false;
        }
    }

    /**
     * Parses the raw text from the custom questions textarea.
     * Each line should be "Question => Answer".
     * @param {string} text - The raw text from the textarea.
     * @returns {Array<{question: string, answer: string}>} Parsed question objects.
     * @throws {Error} If any line has an invalid format.
     * @private
     */
    _parseCustomQuestionsText(text) {
        const lines = text.replace(/\r/g, '').split('\n');
        const questions = [];
        const errors = [];

        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine.startsWith('//')) return; // Skip empty/comment lines

            const parts = trimmedLine.split('=>');
            if (parts.length === 2) {
                const question = parts[0].trim();
                const answer = parts[1].trim();
                if (question && answer) {
                    questions.push({ question, answer });
                } else {
                    errors.push(`Regel ${index + 1}: Vraag of antwoord is leeg.`);
                }
            } else {
                errors.push(`Regel ${index + 1}: Ongeldig formaat (gebruik "Vraag => Antwoord").`);
            }
        });

        if (errors.length > 0) {
            throw new Error(`Fouten in vragenlijst:\n${errors.join('\n')}`);
        }

        return questions;
    }

    /**
     * Formats an array of question objects back into text for the textarea.
     * @param {Array<{question: string, answer: string}>} questions
     * @returns {string}
     */
    formatQuestionsForTextarea(questions) {
        if (!Array.isArray(questions)) return '';
        return questions.map(q => `${q.question} => ${q.answer}`).join('\n');
    }

    /**
     * Deletes a custom question sheet.
     * Needs confirmation before deleting.
     * @param {string} sheetId - The ID of the sheet to delete.
     * @returns {boolean} True if deletion was successful (after confirmation), false otherwise.
     */
    deleteCustomSheet(sheetId) {
        const sheetToDelete = this.customSheets.get(sheetId);
        if (!sheetToDelete) {
            console.warn(`[QuestionsManager] Cannot delete sheet ${sheetId}: Not found.`);
            return false;
        }

        // *** Replace confirm() with ConfirmationDialog ***
        const confirmationDialog = uiManager.components.get('ConfirmationDialog');
        if (!confirmationDialog) {
             console.error("[QuestionsManager] ConfirmationDialog component not found in UIManager!");
             // Use the template for the error message
             eventBus.emit(Events.System.ShowFeedback, { message: getTextTemplate('deleteSheetError'), level: "error" });
             return false;
        }

        const sheetName = sheetToDelete.name || sheetId; // Get the name for the message

        confirmationDialog.show({
            title: getTextTemplate('deleteSheetTitle'), // Get text from template
            message: getTextTemplate('deleteSheetMessage', { '%NAME%': sheetName }), // Get text and substitute %NAME%
            okText: getTextTemplate('deleteSheetOk'), // Get text from template
            cancelText: getTextTemplate('deleteSheetCancel'), // Get text from template
            context: sheetId, // Pass sheetId as context
            onConfirm: (contextSheetId) => {
                console.log(`[QuestionsManager] Confirmed deletion for: ${contextSheetId}`);
                if (this.customSheets.delete(contextSheetId)) {
                    this._saveCustomSheets();
                    this._updateSelectableItems();
                    console.log(`[QuestionsManager] Custom sheet ${contextSheetId} deleted.`);
                    // Let the coordinator emit success events
                } else {
                     console.error(`[QuestionsManager] Failed to delete sheet ${contextSheetId} from map after confirmation.`);
                     // Let the coordinator emit failure events
                }
            },
            onCancel: (contextSheetId) => {
                console.log(`[QuestionsManager] Cancelled deletion for: ${contextSheetId}`);
                 // Let the coordinator know deletion was cancelled if needed
            }
        });

        // Return false immediately because the actual deletion happens asynchronously after confirmation
        // The coordinator should handle success/failure based on events from the dialog/callback
        return false; 
    }

    // --- Getting Sheets ---

    /**
     * Returns the combined list of selectable items (categories from default sheets + custom sheets).
     * @returns {Array<{id: string, name: string, isCustom: boolean}>}
     */
    getAvailableSheets() {
        if (!this.isInitialized) {
            console.warn("[QuestionsManager] getAvailableSheets called before initialization complete. Results may be incomplete.");
        }
        // Return a copy to prevent external modification
        return [...this.selectableItems];
    }

    /**
     * Retrieves a flat array of questions for a given selectable item ID.
     * Handles custom sheets ID or composite IDs ('fileId:Category Title') for default sheets.
     * @param {string} selectableId - The ID from the selectableItems list.
     * @returns {Promise<Array<{question: string, answer: string}>>} A promise resolving to the questions array.
     * @throws {Error} If the ID is invalid or questions cannot be retrieved.
     */
    async getQuestionsForSheet(selectableId) {
        await this._ensureInitialized();

        console.debug(`[QuestionsManager] getQuestionsForSheet requested for selectable ID: ${selectableId}`);

        // 1. Check if it's a known custom sheet ID
        if (this.customSheets.has(selectableId)) {
            console.debug(`[QuestionsManager] Returning questions from custom sheet: ${selectableId}`);
            const customSheetData = this.customSheets.get(selectableId);
            return customSheetData.questions || [];
        }

        // 2. Try to parse as composite ID 'fileId:Category Title'
        const parts = selectableId.split(':');
        if (parts.length >= 2) { // Allow for ':' within category title itself
            const fileId = parts[0];
            const categoryTitle = parts.slice(1).join(':'); // Re-join if title had colons

            // Check cache for the parsed file object
            if (this.loadedQuestionsCache.has(fileId)) {
                const categoryObject = this.loadedQuestionsCache.get(fileId);
                // Check if the specific category exists within the cached object
                if (categoryObject && typeof categoryObject === 'object' && categoryObject.hasOwnProperty(categoryTitle)) {
                    console.debug(`[QuestionsManager] Returning questions for category '${categoryTitle}' from file '${fileId}'`);
                    return categoryObject[categoryTitle] || []; // Return the array for that category
                } else {
                    console.error(`[QuestionsManager] Category '${categoryTitle}' not found within cached data for file '${fileId}'.`);
                    throw new Error(getTextTemplate('qmGetErrorCategoryNotFound', {
                        '%CATEGORY%': categoryTitle,
                        '%FILE%': fileId
                    }));
                }
            } else {
                // This means the file wasn't loaded/cached during init, which is an error
                console.error(`[QuestionsManager] File data for '${fileId}' not found in cache for selectable ID: ${selectableId}. Initialization incomplete?`);
                throw new Error(getTextTemplate('qmGetErrorBaseData', { '%FILE%': fileId }));
            }
        } else {
             // 3. ID is not custom and not a valid composite ID format
             console.error(`[QuestionsManager] Invalid selectable ID format or sheet not found: ${selectableId}`);
             throw new Error(getTextTemplate('qmGetErrorInvalidId', { '%ID%': selectableId }));
        }
    }

    /**
     * Retrieves the actual question data for a list of selectable sheet IDs.
     * Handles both default (composite ID) and custom sheets.
     * Ensures initialization is complete before proceeding.
     *
     * @param {string[]} selectableIds - An array of sheet IDs (e.g., ["tafels:Tafel van 2", "custom_123"]).
     * @returns {Promise<object>} A promise resolving to an object { sheets: Array<{ id: string, name: string, isCustom: boolean, questions: Array<{question: string, answer: string}> }> }.
     * @throws {Error} If initialization fails or a sheet ID is invalid.
     */
    async getQuestionsForSheets(selectableIds) {
        await this._ensureInitialized();
        console.log(`[QuestionsManager] Getting combined questions for IDs:`, selectableIds);

        const results = {
            sheets: []
        };

        if (!Array.isArray(selectableIds) || selectableIds.length === 0) {
            console.warn("[QuestionsManager] getQuestionsForSheets called with empty or invalid IDs array.");
            return results; // Return empty structure
        }

        for (const id of selectableIds) {
            try {
                const sheetInfo = this.selectableItems.find(item => item.id === id);
                if (!sheetInfo) {
                    console.warn(`[QuestionsManager] Selectable item not found for ID: ${id}. Skipping.`);
                    continue;
                }

                let questions = [];
                if (sheetInfo.isCustom) {
                    // Custom sheet
                    const customSheetData = this.customSheets.get(id);
                    if (customSheetData && Array.isArray(customSheetData.questions)) {
                        questions = customSheetData.questions;
                    } else {
                        console.warn(`[QuestionsManager] Custom sheet data missing or invalid for ID: ${id}. Skipping.`);
                        continue;
                    }
                } else {
                    // Default sheet (composite ID: fileId:categoryTitle)
                    const parts = id.split(':');
                    if (parts.length < 2) { // Allow for titles containing colons
                         console.warn(`[QuestionsManager] Invalid default sheet ID format: ${id}. Skipping.`);
                         continue;
                    }
                    const fileId = parts[0];
                    const categoryTitle = parts.slice(1).join(':'); // Re-join title if it contained colons

                    const cachedCategoryObject = this.loadedQuestionsCache.get(fileId);
                    if (cachedCategoryObject && cachedCategoryObject[categoryTitle] && Array.isArray(cachedCategoryObject[categoryTitle])) {
                        questions = cachedCategoryObject[categoryTitle];
                    } else {
                        console.warn(`[QuestionsManager] Default category questions not found in cache for ID: ${id} (File: ${fileId}, Category: ${categoryTitle}). Skipping.`);
                        continue;
                    }
                }
                
                 // Ensure questions have the correct format
                 const formattedQuestions = questions.map(q => ({
                     question: q.question || '',
                     answer: q.answer || '' 
                 }));

                results.sheets.push({
                    id: id,
                    name: sheetInfo.name, // Use the name from selectableItems
                    isCustom: sheetInfo.isCustom,
                    questions: formattedQuestions
                });

            } catch (error) {
                console.error(`[QuestionsManager] Error processing sheet ID ${id}:`, error);
                // Optionally re-throw or just log and continue with other sheets
            }
        }

        console.log(`[QuestionsManager] Successfully retrieved data for ${results.sheets.length} sheets.`);
        return results;
    }

    /**
     * Gets a display-friendly name for a given sheet ID.
     * Placeholder implementation - adjust based on how sheet data is stored.
     * @param {string} sheetId - The ID of the sheet (e.g., 'default_1', 'custom_abc').
     * @returns {string|null} The display name or null if not found.
     */
    getSheetDisplayName(sheetId) {
        // Find in default categories
        const defaultSheet = this.defaultCategories.find(cat => cat.id === sheetId);
        if (defaultSheet) {
            return defaultSheet.name;
        }
        // Find in custom sheets (assuming they are stored with id and name)
        const customSheet = this.customSheets.find(sheet => sheet.id === sheetId);
        if (customSheet) {
            return customSheet.name; // Assuming custom sheets have a 'name' property
        }
        console.warn(`[QuestionsManager] Display name not found for sheetId: ${sheetId}`);
        return null; // Not found
    }

    /** Refreshes the `selectableItems` array based on current default and custom sheets. */
    _updateSelectableItems() {
        console.debug("[QuestionsManager] Refreshing selectable items list.");
        this.selectableItems = [];
        // Add default categories from cache
        this.loadedQuestionsCache.forEach((categoryObject, fileId) => {
            Object.keys(categoryObject).forEach(categoryTitle => {
                this.selectableItems.push({
                    id: `${fileId}:${categoryTitle}`, // Composite ID
                    name: categoryTitle,
                    isCustom: false
                });
            });
        });
        // Add custom sheets
        this.customSheets.forEach((sheetData, sheetId) => {
            this.selectableItems.push({
                id: sheetId,
                name: sheetData.name || getTextTemplate('qmDefaultCustomName'),
                isCustom: true
            });
        });
        console.debug(`[QuestionsManager] Selectable items refreshed. Count: ${this.selectableItems.length}`);
    }

    /**
     * Safely adds a custom sheet received from a host.
     * Prevents overwriting existing sheets with the same ID.
     * @param {object} sheetData - The sheet data object { id, name, isCustom, questions }.
     * @param {string} originHostName - The name of the host the sheet came from.
     */
    addReceivedCustomSheet(sheetData, originHostName) {
        if (!sheetData || !sheetData.id || !sheetData.name || !Array.isArray(sheetData.questions) || !sheetData.isCustom) {
            console.warn("[QuestionsManager] Attempted to add invalid received custom sheet data:", sheetData);
            return; // Invalid data
        }

        if (this.customSheets.has(sheetData.id)) {
            console.log(`[QuestionsManager] Custom sheet with ID ${sheetData.id} already exists locally. Skipping save.`);
            // Optional: Emit feedback event?
            // eventBus.emit(Events.System.ShowFeedback, { message: `Lijst '${sheetData.name}' bestaat al lokaal.`, level: 'info' });
            return; // Do not overwrite existing sheet
        }

        // Add origin host name to the data before saving
        const dataToSave = {
            ...sheetData,
            originHostName: originHostName || 'Unknown Host' // Store host name
        };

        this.customSheets.set(sheetData.id, dataToSave);
        this._saveCustomSheets(); // Persist to localStorage
        this._updateSelectableItems(); // Update the internal list for UI

        console.log(`[QuestionsManager] Saved received custom sheet '${sheetData.name}' (ID: ${sheetData.id}) from host '${originHostName}'.`);
        eventBus.emit(Events.System.ShowFeedback, { message: `Nieuwe lijst '${sheetData.name}' ontvangen en opgeslagen.`, level: 'success' });
    }
}

// Create and export a singleton instance
const questionsManager = new QuestionsManager();
export default questionsManager; 